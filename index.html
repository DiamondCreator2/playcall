<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Play Call Live</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
            padding-top: 64px; /* Space for fixed header */
        }
        .admin-input {
            @apply border border-gray-300 rounded-md p-1 w-full text-sm focus:ring-blue-500 focus:border-blue-500;
        }
		.nav-link {
            transition: color 0.15s, background-color 0.15s;
        }
        /* Message Box Overlay */
        .message-box-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .message-box-content {
            background-color: white;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            max-width: 400px;
            text-align: center;
        }
        
    </style>
</head>
<body class="bg-gray-50 min-h-screen">

    <!-- Custom Message Box Modal -->
    <div id="message-box-container" class="hidden fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center transition-opacity duration-300">
        <div class="bg-white rounded-lg shadow-2xl p-6 max-w-sm w-full">
            <h3 id="message-box-title" class="text-xl font-bold mb-4 text-gray-800">Title</h3>
            <p id="message-box-body" class="text-gray-600 mb-6">Body</p>
            <div class="flex justify-end">
                <button id="message-box-ok" class="bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700 transition duration-150">
                    OK
                </button>
            </div>
        </div>
    </div>

    <!-- NEW: Custom Confirm Box Modal -->
    <div id="confirm-box-container" class="hidden fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center transition-opacity duration-300">
        <div class="bg-white rounded-lg shadow-2xl p-6 max-w-sm w-full">
            <h3 id="confirm-box-title" class="text-xl font-bold mb-4 text-gray-800">Confirm Action</h3>
            <p id="confirm-box-body" class="text-gray-600 mb-6">Are you sure?</p>
            <div class="flex justify-end space-x-3">
                <button id="confirm-box-cancel" class="bg-gray-200 text-gray-800 px-4 py-2 rounded-lg hover:bg-gray-300 transition duration-150">
                    Cancel
                </button>
                <button id="confirm-box-ok" class="bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700 transition duration-150">
                    Confirm
                </button>
            </div>
        </div>
    </div>
    
    <!-- Header: Navigation and Logo -->
    <header class="fixed top-0 left-0 w-full bg-gray-900 text-white shadow-xl z-50">
        <div class="max-w-7xl mx-auto px-2 sm:px-6 lg:px-8 h-auto">
            
            <div class="flex items-center justify-between h-16">
                
                <!-- 1. LEFT SIDE GROUP: Title/Logo + Desktop Links -->
                <div class="flex items-center space-x-6">
                    
                    <!-- Title/Logo -->
                    <div class="flex items-center flex-shrink-0">
                        <span class="text-2xl sm:text-4xl font-black tracking-tight text-white">
                            Play Call
                        </span>
                        
                        <span class="
                            ml-2 sm:ml-3 
                            bg-red-600 
                            text-white 
                            text-xs 
                            font-extrabold 
                            px-2.5 
                            py-1 
                            rounded-lg 
                            uppercase 
                            tracking-widest 
                            shadow-lg 
                            shadow-red-800/50 
                            self-center 
                            transform 
                            scale-95 
                            hover:scale-100 
                            transition duration-150
                            cursor-default
                        ">
                            Live
                        </span>
                    </div>
                    
                    <!-- Desktop Navigation -->
                    <nav id="desktop-nav" class="hidden sm:flex space-x-4">
                        <a href="#" id="dashboard-link" class="nav-link text-red-400 hover:text-red-200 transition duration-150 ease-in-out font-semibold">
                            Dashboard
                        </a>
                        <a href="#" id="scores-link" class="nav-link text-white hover:text-red-200 transition duration-150 ease-in-out font-semibold">
                            Live Scores
                        </a>
                        <a href="#" id="admin-link" class="nav-link text-white hover:text-red-200 transition duration-150 ease-in-out font-semibold">
                            Admin Panel
                        </a>
                        <!-- NEW ACCOUNT LINK -->
                        <a href="#" id="account-link" class="nav-link text-white hover:text-red-200 transition duration-150 ease-in-out font-semibold">
                            Account
                        </a>
                    </nav>

                </div>


                <!-- 2. RIGHT SIDE: Auth Status & Mobile Menu Button -->
                <div class="flex items-center space-x-4">
                    
                    <!-- NEW: Auth Status -->
                    <div id="auth-status" class="hidden sm:flex items-center space-x-3">
                        <span id="auth-welcome" class="text-sm font-medium text-gray-300">Loading...</span>
                        <button id="auth-action-btn" class="bg-red-600 text-white px-3 py-1.5 rounded-lg text-sm font-semibold hover:bg-red-700 transition duration-150">
                            Login
                        </button>
                    </div>
                    
                    <!-- Mobile Menu Button -->
                    <button id="mobile-menu-button" class="sm:hidden p-2 rounded-md hover:bg-gray-700 transition duration-150">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
                        </svg>
                    </button>
                </div>
            </div>
            
            <!-- 3. Mobile Menu Content (Vertical Links, hidden by default) -->
            <div id="mobile-menu" class="hidden pb-4 sm:hidden bg-gray-900 z-50">
                <a href="#" id="dashboard-link-mobile" class="nav-link-mobile block py-2 px-3 rounded-md text-base font-medium text-red-400 hover:bg-gray-700 hover:text-red-400 transition duration-150">Dashboard</a>
    		    <a href="#" id="scores-link-mobile" class="nav-link-mobile block py-2 px-3 rounded-md text-base font-medium text-white hover:bg-gray-700 hover:text-red-400 transition duration-150">Live Scores</a>
    		    <a href="#" id="admin-link-mobile" class="nav-link-mobile block py-2 px-3 rounded-md text-base font-medium text-white hover:bg-gray-700 hover:text-red-400 transition duration-150">Admin Panel</a>
                <!-- NEW ACCOUNT LINK -->
                <a href="#" id="account-link-mobile" class="nav-link-mobile block py-2 px-3 rounded-md text-base font-medium text-white hover:bg-gray-700 hover:text-red-400 transition duration-150">Account</a>
                
                <!-- NEW: Auth Status for Mobile -->
                <div id="auth-status-mobile" class="px-3 pt-4 pb-2 border-t border-gray-700">
                    <span id="auth-welcome-mobile" class="block text-sm font-medium text-gray-300 mb-3">Loading...</span>
                    <button id="auth-action-btn-mobile" class="w-full bg-red-600 text-white px-3 py-2 rounded-lg text-sm font-semibold hover:bg-red-700 transition duration-150">
                        Login
                    </button>
                </div>
            </div>
        </div>
    </header>
   

    <!-- Main Content Area -->
    <main class="max-w-7xl mx-auto py-6 sm:px-6 lg:px-8">
        
        <!-- NEW: Auth View (Login/Register) -->
        <div id="auth-view" class="hidden px-4 py-4 sm:px-0">
            <div class="max-w-md mx-auto bg-white p-8 rounded-xl shadow-2xl">
                
                <!-- Login Form (Default) -->
                <div id="login-form">
                    <h2 class="text-3xl font-extrabold text-gray-900 mb-6 text-center">Login</h2>
                    <div class="space-y-4">
                        <div>
                            <label for="login-email" class="block text-sm font-medium text-gray-700">Email</label>
                            <input type="email" id="login-email" class="admin-input mt-1 w-full" placeholder="you@example.com">
                        </div>
                        <div>
                            <label for="login-password" class="block text-sm font-medium text-gray-700">Password</label>
                            <input type="password" id="login-password" class="admin-input mt-1 w-full" placeholder="••••••••">
                        </div>
                        <button id="login-btn" class="w-full bg-red-600 text-white font-semibold py-2 rounded-lg hover:bg-red-700 transition duration-150 shadow-md">
                            Sign In
                        </button>
                    </div>

                    <!-- NEW: Google Sign-in -->
                    <div class="relative my-6">
                        <div class="absolute inset-0 flex items-center">
                            <div class="w-full border-t border-gray-300"></div>
                        </div>
                        <div class="relative flex justify-center text-sm">
                            <span class="px-2 bg-white text-gray-500">OR</span>
                        </div>
                    </div>
                    <div>
                        <button id="google-login-btn" class="w-full flex items-center justify-center py-2 px-4 border border-gray-300 rounded-lg shadow-sm bg-white text-sm font-medium text-gray-700 hover:bg-gray-50 transition duration-150">
                            <svg class="w-5 h-5 mr-2" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" width="48px" height="48px"><path fill="#FFC107" d="M43.611,20.083H42V20H24v8h11.303c-1.649,4.657-6.08,8-11.303,8c-6.627,0-12-5.373-12-12c0-6.627,5.373-12,12-12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C12.955,4,4,12.955,4,24c0,11.045,8.955,20,20,20c11.045,0,20-8.955,20-20C44,22.659,43.862,21.35,43.611,20.083z"/><path fill="#FF3D00" d="M6.306,14.691l6.571,4.819C14.655,15.108,18.961,12,24,12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C16.318,4,9.656,8.337,6.306,14.691z"/><path fill="#4CAF50" d="M24,44c5.166,0,9.86-1.977,13.409-5.192l-6.19-5.238C29.211,35.091,26.715,36,24,36c-5.223,0-9.64-3.657-11.303-8H6.306C9.656,35.663,16.318,40,24,40z"/><path fill="#1976D2" d="M43.611,20.083H42V20H24v8h11.303c-0.792,2.237-2.231,4.166-4.087,5.571c0.001-0.001,0.002-0.001,0.003-0.002l6.19,5.238C36.971,39.205,44,34,44,24C44,22.659,43.862,21.35,43.611,20.083z"/></svg>
                            Sign in with Google
                        </button>
                    </div>
                    <!-- End Google Sign-in -->

                    <p class="text-sm text-center text-gray-600 mt-6">
                        Don't have an account? 
                        <a href="#" id="show-register-form" class="font-medium text-red-600 hover:text-red-500">Create one</a>
                    </p>
                </div>

                <!-- Register Form (Hidden) -->
                <div id="register-form" class="hidden">
                    <h2 class="text-3xl font-extrabold text-gray-900 mb-6 text-center">Create Account</h2>
                    <div class="space-y-4">
                        <div>
                            <label for="register-email" class="block text-sm font-medium text-gray-700">Email</label>
                            <input type="email" id="register-email" class="admin-input mt-1 w-full" placeholder="you@example.com">
                        </div>
                        <div>
                            <label for="register-password" class="block text-sm font-medium text-gray-700">Password</label>
                            <input type="password" id="register-password" class="admin-input mt-1 w-full" placeholder="6+ characters">
                        </div>
                        <button id="register-btn" class="w-full bg-red-600 text-white font-semibold py-2 rounded-lg hover:bg-red-700 transition duration-150 shadow-md">
                            Create Account
                        </button>
                    </div>

                    <!-- NEW: Google Sign-up -->
                    <div class="relative my-6">
                        <div class="absolute inset-0 flex items-center">
                            <div class="w-full border-t border-gray-300"></div>
                        </div>
                        <div class="relative flex justify-center text-sm">
                            <span class="px-2 bg-white text-gray-500">OR</span>
                        </div>
                    </div>
                    <div>
                        <button id="google-register-btn" class="w-full flex items-center justify-center py-2 px-4 border border-gray-300 rounded-lg shadow-sm bg-white text-sm font-medium text-gray-700 hover:bg-gray-50 transition duration-150">
                            <svg class="w-5 h-5 mr-2" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" width="48px" height="48px"><path fill="#FFC107" d="M43.611,20.083H42V20H24v8h11.303c-1.649,4.657-6.08,8-11.303,8c-6.627,0-12-5.373-12-12c0-6.627,5.373-12,12-12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C12.955,4,4,12.955,4,24c0,11.045,8.955,20,20,20c11.045,0,20-8.955,20-20C44,22.659,43.862,21.35,43.611,20.083z"/><path fill="#FF3D00" d="M6.306,14.691l6.571,4.819C14.655,15.108,18.961,12,24,12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C16.318,4,9.656,8.337,6.306,14.691z"/><path fill="#4CAF50" d="M24,44c5.166,0,9.86-1.977,13.409-5.192l-6.19-5.238C29.211,35.091,26.715,36,24,36c-5.223,0-9.64-3.657-11.303-8H6.306C9.656,35.663,16.318,40,24,40z"/><path fill="#1976D2" d="M43.611,20.083H42V20H24v8h11.303c-0.792,2.237-2.231,4.166-4.087,5.571c0.001-0.001,0.002-0.001,0.003-0.002l6.19,5.238C36.971,39.205,44,34,44,24C44,22.659,43.862,21.35,43.611,20.083z"/></svg>
                            Sign up with Google
                        </button>
                    </div>
                    <!-- End Google Sign-up -->

                    <p class="text-sm text-center text-gray-600 mt-6">
                        Already have an account? 
                        <a href="#" id="show-login-form" class="font-medium text-red-600 hover:text-red-500">Sign in</a>
                    </p>
                </div>

            </div>
        </div>
        
        <!-- Dashboard View (Followed Games) -->
        <div id="dashboard-view" class="hidden px-4 py-4 sm:px-0 space-y-8">
            <h2 class="text-3xl font-extrabold text-gray-900 mb-2">Your Dashboard</h2>
            
            <!-- User ID Display -- REMOVED -->
            
            <!-- Friend Activity Section (Mock) -->
            <div>
                <h3 class="text-2xl font-bold text-gray-800 mb-4 border-b pb-2">Friend Activity (Mock)</h3>
                <div id="friend-activity-list">
                    <!-- Friend activity list will be injected here -->
                </div>
            </div>
            
            <!-- Followed Games Section (Firestore Data) -->
            <div>
                <h3 class="text-2xl font-bold text-gray-800 mb-4 border-b pb-2">Followed Games</h3>
                <div id="no-followed-games" class="p-6 text-center text-gray-500 bg-white rounded-xl shadow-lg border-2 border-dashed border-gray-300">
                    You aren't following any games yet. Head over to the Live Game Feed to start tracking!
                </div>
                <div id="followed-games-container" class="flex flex-wrap gap-4 overflow-x-auto pb-4">
                    <!-- Followed game cards will be injected here -->
                </div>
            </div>

            
        </div>

        <!-- Scores View (Game Feed) -->
        <div id="scores-view" class="hidden space-y-6">
            <h2 class="text-3xl font-bold text-gray-800">Live Game Feed</h2>
            
            <!-- Filter Bar -->
            <div class="flex flex-col sm:flex-row items-start sm:items-center space-y-3 sm:space-y-0 sm:space-x-4 p-4 bg-white rounded-xl shadow-lg">
                <label for="league-filter" class="font-semibold text-gray-700">League:</label>
                <select id="league-filter" class="border border-gray-300 rounded-lg p-2 focus:ring-red-500 focus:border-red-500">
                    <!-- Options will be populated by JS -->
                </select>
                <label for="status-filter" class="font-semibold text-gray-700">Status:</label>
                <select id="status-filter" class="border border-gray-300 rounded-lg p-2 focus:ring-red-500 focus:border-red-500">
                    <option value="All">All</option>
                    <option value="In Progress">In Progress</option>
                    <option value="Scheduled">Scheduled</option>
                    <option value="Final">Final</option>
                </select>
                <input type="text" id="team-search" placeholder="Search team name..." class="flex-grow border border-gray-300 rounded-lg p-2 focus:ring-red-500 focus:border-red-500 sm:ml-auto">
            </div>

            <div id="scores-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                <!-- Game cards will be inserted here -->
            </div>
        </div>

        <!-- Detail View (Single Game) -->
        <div id="detail-view" class="hidden px-4 py-4 sm:px-0">
            <button id="back-to-scores" class="flex items-center text-red-600 hover:text-red-700 mb-6 font-semibold">
                <svg class="w-5 h-5 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg>
                Back to Feed
            </button>
            <div id="detail-content" class="bg-white p-8 rounded-xl shadow-2xl">
                <!-- Game details and chat mock injected here -->
            </div>
        </div>

        <!-- Admin Panel View -->
        <div id="admin-view" class="hidden px-4 py-4 sm:px-0">
            <h2 class="text-3xl font-extrabold text-gray-900 mb-6">Admin Panel</h2>
            
            <!-- NEW: Live Prompt Control Panel -->
            <div class="bg-white p-6 rounded-xl shadow-lg mb-8 border-t-4 border-red-600">
                <h3 class="text-2xl font-bold text-gray-800 mb-4">Create New Live Prompt (Yes/No)</h3>
                <p class="text-sm text-gray-600 mb-4">Create a new real-time Yes/No question for a specific game. Only one prompt can be active per game.</p>
                <div class="grid grid-cols-1 md:grid-cols-4 gap-4 items-end">
                    <!-- Game ID Input -->
                    <div class="md:col-span-1">
                        <label for="prompt-game-id" class="block text-sm font-medium text-gray-700">Game ID (e.g., NFL-12345)</label>
                        <input type="text" id="prompt-game-id" placeholder="NFL-12345" class="admin-input mt-1">
                    </div>
                    
                    <!-- Prompt Input -->
                    <div class="md:col-span-2">
                        <label for="prompt-question" class="block text-sm font-medium text-gray-700">Question (Yes/No Prompt)</label>
                        <input type="text" id="prompt-question" placeholder="Will the next play be a pass?" class="admin-input mt-1">
                    </div>
                    
                    <!-- Create Prompt Button -->
                    <div class="md:col-span-1">
                        <button id="prompt-send-btn" class="w-full bg-red-600 text-white font-semibold py-2 rounded-lg hover:bg-red-700 transition duration-150 shadow-md">
                            Create Live Prompt
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- NEW: Active & Resolved Prompts List -->
            <div class="bg-white p-6 rounded-xl shadow-lg mt-8">
                <h3 class="text-2xl font-bold text-gray-800 mb-4">Active & Resolved Prompts</h3>
                <p class="text-sm text-gray-600 mb-4">Set the final answer here. Resolving a prompt will expire it for viewers.</p>
                
                <div class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Game ID</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Question</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Answer</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="admin-prompt-list" class="bg-white divide-y divide-gray-200">
                            <!-- Prompt rows injected here -->
                        </tbody>
                    </table>
                    <p id="no-prompts-message" class="text-center text-gray-500 py-4 hidden">No active or recently resolved prompts found.</p>
                </div>
            </div>

            <!-- START: NEW Clear Leaderboard (Danger Zone) -->
            <div class="bg-white p-6 rounded-xl shadow-lg mt-8 border-t-4 border-red-600">
                <h3 class="text-2xl font-bold text-red-700 mb-2">Danger Zone: Clear Leaderboard</h3>
                <p class="text-sm text-gray-600 mb-4">
                    Permanently delete all user scores for a specific game. This action cannot be undone. 
                    The leaderboard will be empty until new scores are recorded.
                </p>
                <div class="flex flex-col sm:flex-row gap-4 items-end">
                    <div class="flex-grow w-full">
                        <label for="clear-leaderboard-game-id" class="block text-sm font-medium text-gray-700">Game ID (e.g., NFL-12345)</label>
                        <input type="text" id="clear-leaderboard-game-id" placeholder="NFL-12345" class="admin-input mt-1">
                    </div>
                    <button id="clear-leaderboard-btn" class="w-full sm:w-auto bg-red-700 text-white font-semibold py-2 px-6 rounded-lg hover:bg-red-800 transition duration-150 shadow-md">
                        Clear All Scores
                    </button>
                </div>
            </div>
            <!-- END: NEW Clear Leaderboard (Danger Zone) -->
            
            <!-- Existing Game List -->
            <div class="bg-white p-6 rounded-xl shadow-lg overflow-x-auto mt-8">
                <h3 class="text-2xl font-bold text-gray-800 mb-4">Live Game Scoreboard (Read-Only)</h3>
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">ID</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">League</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Teams</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Time</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Score H/A (R/O)</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Actions</th>
                        </tr>
                    </thead>
                    <tbody id="admin-game-list" class="bg-white divide-y divide-gray-200">
                        <!-- Game rows injected here -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- NEW: Account Settings View -->
        <div id="account-view" class_name="hidden px-4 py-4 sm:px-0 space-y-8">
            <h2 class="text-3xl font-extrabold text-gray-900 mb-2">Account Settings</h2>
            
            <!-- Nickname Section -->
            <div class="bg-white p-6 rounded-xl shadow-lg border-t-4 border-red-600">
                <h3 class="text-2xl font-bold text-gray-800 mb-2">Public Nickname</h3>
                <p class="text-sm text-gray-600 mb-4">This name will appear on game leaderboards. Your User ID is: <code class="text-xs bg-gray-100 p-1 rounded-md" id="user-id-display-account">Loading...</code></p>
                <div class="flex flex-col sm:flex-row gap-4 items-center">
                    <div class="flex-grow w-full">
                        <label for="nickname-input-account" class="block text-sm font-medium text-gray-700">Set Nickname</label>
                        <input type="text" id="nickname-input-account" placeholder="Enter your nickname..." class="admin-input mt-1 w-full">
                    </div>
                    <button id="save-nickname-btn-account" class="w-full sm:w-auto bg-red-600 text-white font-semibold py-2 px-6 rounded-lg hover:bg-red-700 transition duration-150 shadow-md sm:self-end">
                        Save
                    </button>
                </div>
                <p class="text-sm text-gray-500 mt-3">Current Nickname: <span id="current-nickname-display-account" class="font-bold text-gray-700">Loading...</span></p>
            </div>

            <!-- Change Password Section -->
            <div class="bg-white p-6 rounded-xl shadow-lg border-t-4 border-gray-300">
                <h3 class="text-2xl font-bold text-gray-800 mb-2">Change Password</h3>
                <p class="text-sm text-gray-600 mb-4">Update your account password. You will be logged out after a successful change.</p>
                <div class="space-y-4 max-w-md">
                    <div>
                        <label for="current-password" class="block text-sm font-medium text-gray-700">Current Password</label>
                        <input type="password" id="current-password" class="admin-input mt-1 w-full" placeholder="••••••••">
                    </div>
                    <div>
                        <label for="new-password" class="block text-sm font-medium text-gray-700">New Password</label>
                        <input type="password" id="new-password" class="admin-input mt-1 w-full" placeholder="6+ characters">
                    </div>
                    <div>
                        <label for="confirm-new-password" class="block text-sm font-medium text-gray-700">Confirm New Password</label>
                        <input type="password" id="confirm-new-password" class="admin-input mt-1 w-full" placeholder="6+ characters">
                    </div>
                    <button id="change-password-btn" class="w-full bg-blue-600 text-white font-semibold py-2 rounded-lg hover:bg-blue-700 transition duration-150 shadow-md">
                        Update Password
                    </button>
                </div>
            </div>

            <!-- Delete Account Section -->
            <div class="bg-white p-6 rounded-xl shadow-lg border-t-4 border-red-600">
                <h3 class="text-2xl font-bold text-red-700 mb-2">Danger Zone</h3>
                <p class="text-sm text-gray-600 mb-4">Deleting your account is permanent and cannot be undone. All your data, including followed games and leaderboard scores, will be lost.</p>
                <div class="space-y-4 max-w-md">
                    <div>
                        <label for="delete-account-password" class="block text-sm font-medium text-gray-700">Enter Password to Confirm Deletion</label>
                        <input type="password" id="delete-account-password" class="admin-input mt-1 w-full" placeholder="••••••••">
                    </div>
                    <button id="delete-account-btn" class="w-full bg-red-700 text-white font-semibold py-2 rounded-lg hover:bg-red-800 transition duration-150 shadow-md">
                        Delete My Account
                    </button>
                </div>
            </div>

        </div>

    </main>

    <!-- Firebase SDK Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        // MODIFIED: Added GoogleAuthProvider, signInWithPopup, getAdditionalUserInfo
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, updatePassword, EmailAuthProvider, reauthenticateWithCredential, deleteUser, setPersistence, browserLocalPersistence, GoogleAuthProvider, signInWithPopup, getAdditionalUserInfo } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        // MODIFIED: Added deleteField
        import { getFirestore, doc, setDoc, onSnapshot, collection, increment, writeBatch, FieldValue, query, where, updateDoc, addDoc, getDocs, getDoc, deleteDoc, orderBy, deleteField } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Use Debug logging for better visibility in the console
        setLogLevel('Debug');

        // --- GLOBAL FIREBASE/APP VARS ---
        
        // ====================================================================================
        // IMPORTANT: USER-PROVIDED FALLBACK CONFIGURATION
        // ====================================================================================
        const USER_FIREBASE_CONFIG = {
            apiKey: "AIzaSyCsunmtOlyDZHxzVBOkvQsduSyg4MU50LA", // <-- REPLACE THIS
            authDomain: "playcallbackend.firebaseapp.com", // <-- REPLACE THIS
            projectId: "playcallbackend", // <-- REPLACE THIS
            storageBucket: "playcallbackend.firebasestorage.app",
            messagingSenderId: "977048745219",
            appId: "1:977048745219:web:39669929d446eddaab6536",
            measurementId: "G-YXELM1JJSH"
        };
        // ====================================================================================

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        let resolvedFirebaseConfig;
        try {
            const environmentConfig = typeof __firebase_config !== 'undefined' && __firebase_config ? JSON.parse(__firebase_config) : {};
            if (environmentConfig.projectId) {
                resolvedFirebaseConfig = environmentConfig;
            } else {
                resolvedFirebaseConfig = USER_FIREBASE_CONFIG;
            }
        } catch (e) {
            console.error("Failed to parse environment config, falling back to USER_FIREBASE_CONFIG.", e);
            resolvedFirebaseConfig = USER_FIREBASE_CONFIG;
        }

        if (!resolvedFirebaseConfig.projectId || resolvedFirebaseConfig.projectId.includes("YOUR_PROJECT_ID")) {
            console.warn("⚠️ Firebase Warning: Running with dummy configuration. Please update the 'USER_FIREBASE_CONFIG' object with your actual Firebase project credentials to run externally.");
        }


        let app, db, auth;
        let userId = null; // Will be set after auth
        let isAuthReady = false; // Flag to indicate auth state is resolved
        let isAnonymous = true; // NEW: Flag to track if user is guest or real
        let userNickname = null; 
        const ADMIN_EMAIL = 'diamond@gmail.com'; // NEW: Admin email constant

        // --- GLOBAL DATA & STATE ---
        let gamesData = []; 
        let followedGames = {}; // PRIVATE: User's list of followed games
        let gameMetadata = {}; // PUBLIC: Real-time follower counts for all games
        let fetchErrorCount = 0;
        
        // --- GLOBAL FIRESTORE UNSUBSCRIBE FUNCTIONS ---
        let unsubscribeGameMetadata = null; // NEW
        let unsubscribeFollowedGames = null; // NEW - This will be removed
        let unsubscribeUserProfile = null; // NEW (was already global, just clarifying)
        
        let unsubscribePromptListener = null; 
        let unsubscribePromptsAdmin = null; 
        let unsubscribeLeaderboardListener = null; 

        // Mock data for the Friend Activity Feed
        const mockFriends = [
            { name: 'Alex M.', status: 'Watching', detail: 'NFL (DAL vs PHI)', color: 'green' },
            { name: 'Jamie P.', status: 'Offline', detail: '', color: 'gray' },
            { name: 'Chris K.', status: 'Watching', detail: 'EPL (MAN U vs LIV)', color: 'green' },
            { name: 'Morgan S.', status: 'Browsing', detail: 'Scores', color: 'blue' },
        ];


        // --- ESPN API ENDPOINT CONFIGURATION ---
        const ESPN_ENDPOINTS = {
            'NFL': 'https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard',
            'NCAAF': 'https://site.api.espn.com/apis/site/v2/sports/football/college-football/scoreboard',
            'NBA': 'https://site.api.espn.com/apis/site/v2/sports/basketball/nba/scoreboard',
            'MLB': 'https://site.api.espn.com/apis/site/v2/sports/baseball/mlb/scoreboard',
            'EPL': 'https://site.api.espn.com/apis/site/v2/sports/soccer/eng.1/scoreboard',
            'NHL': 'https://site.api.espn.com/apis/site/v2/sports/hockey/nhl/scoreboard',
        };

        // --- Custom Message Box (Replacing alert/confirm) ---
        function showMessageBox(title, body) {
            // ... (rest of function is unchanged)
            document.getElementById('message-box-title').textContent = title;
            document.getElementById('message-box-body').textContent = body;
            const container = document.getElementById('message-box-container');
            container.classList.remove('hidden');

            const okButton = document.getElementById('message-box-ok');
            const newOkButton = okButton.cloneNode(true);
            okButton.parentNode.replaceChild(newOkButton, okButton);

            newOkButton.addEventListener('click', () => {
                container.classList.add('hidden');
            });
        }

        // --- NEW: Custom Confirm Box ---
        function showConfirmBox(title, body, onConfirm) {
            document.getElementById('confirm-box-title').textContent = title;
            document.getElementById('confirm-box-body').textContent = body;
            const container = document.getElementById('confirm-box-container');
            container.classList.remove('hidden');

            const okButton = document.getElementById('confirm-box-ok');
            const cancelButton = document.getElementById('confirm-box-cancel');

            // Clone and replace buttons to remove old listeners
            const newOkButton = okButton.cloneNode(true);
            okButton.parentNode.replaceChild(newOkButton, okButton);
            const newCancelButton = cancelButton.cloneNode(true);
            cancelButton.parentNode.replaceChild(newCancelButton, cancelButton);

            newOkButton.addEventListener('click', () => {
                container.classList.add('hidden');
                if (onConfirm) {
                    onConfirm();
                }
            });
            newCancelButton.addEventListener('click', () => {
                container.classList.add('hidden');
            });
        }
        
        // --- Firestore Path Helper Functions ---
        // ... (all helper functions are unchanged)
        // REMOVED: This function is no longer needed as 'followed_games' is part of the public profile.
        /*
        function getFollowedGamesDocRef(dbInstance, currentUserId) {
            if (!dbInstance || !currentUserId) return null;
            if (appId === 'default-app-id') {
                return doc(dbInstance, 'users', currentUserId, 'followed_games', 'user_follows');
            } else {
                return doc(dbInstance, 'artifacts', appId, 'users', currentUserId, 'followed_games', 'user_follows');
            }
        }
        */
        // NEW: This function remains but will also be used to get/set followed games
        function getUserPublicProfileDocRef(dbInstance, currentUserId) {
            if (!dbInstance || !currentUserId) return null;
            if (appId === 'default-app-id') {
                return doc(dbInstance, 'public_user_profiles', currentUserId);
            } else {
                return doc(dbInstance, 'artifacts', appId, 'public', 'data', 'user_profiles', currentUserId);
            }
        }
        function getUserPublicProfileColRef(dbInstance) {
            if (!dbInstance) return null;
            if (appId === 'default-app-id') {
                return collection(dbInstance, 'public_user_profiles');
            } else {
                return collection(dbInstance, 'artifacts', appId, 'public', 'data', 'user_profiles');
            }
        }
        function getGameMetadataColRef(dbInstance) {
            if (!dbInstance) return null;
            if (appId === 'default-app-id') {
                return collection(dbInstance, 'game_metadata');
            } else {
                return collection(dbInstance, 'artifacts', appId, 'public', 'data', 'game_metadata');
            }
        }
        function getGamePromptsColRef(dbInstance) {
            if (!dbInstance) return null;
            if (appId === 'default-app-id') {
                return collection(dbInstance, 'game_prompts');
            } else {
                return collection(dbInstance, 'artifacts', appId, 'public', 'data', 'game_prompts');
            }
        }
        function getPromptVotesColRef(dbInstance, promptId) {
            if (!dbInstance || !promptId) return null;
            if (appId === 'default-app-id') {
                return collection(dbInstance, 'game_prompts', promptId, 'votes');
            } else {
                return collection(dbInstance, 'artifacts', appId, 'public', 'data', 'game_prompts', promptId, 'votes');
            }
        }
        function getLeaderboardColRef(dbInstance, gameId) {
            if (!dbInstance || !gameId) return null;
            if (appId === 'default-app-id') {
                return collection(dbInstance, 'leaderboards', gameId, 'users');
            } else {
                return collection(dbInstance, 'artifacts', appId, 'public', 'data', 'leaderboards', gameId, 'users');
            }
        }

        // --- Date Helper Functions ---
        // ... (getApiDate is unchanged)
        function getApiDate(daysAgo) {
            const date = new Date();
            date.setDate(date.getDate() - daysAgo);
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}${month}${day}`;
        }

        // --- API Data Fetching & Transformation ---
        // ... (transformEspnGame is unchanged)
        function transformEspnGame(league, event) {
            if (!event.competitions || event.competitions.length === 0) return null;
            const competition = event.competitions[0];
            const competitors = competition.competitors;
            if (!competitors || competitors.length < 2) return null;
            const home = competitors.find(c => c.homeAway === 'home');
            const away = competitors.find(c => c.homeAway === 'away');
            if (!home || !away) return null;
            let statusText = event.status.type.detail || event.status.type.shortDetail || 'Scheduled';
            const statusName = event.status.type.name;
            let displayTime = '';
            let gameStatus = 'Scheduled';
            if (statusName === 'STATUS_FINAL' || statusName === 'STATUS_POSTPONED' || statusName === 'STATUS_CANCELLED') {
                gameStatus = 'Final';
            } else if (statusName === 'STATUS_IN_PROGRESS' || statusName === 'STATUS_HALFTIME' || statusName === 'STATUS_DELAYED') {
                gameStatus = 'In Progress';
            } else {
                gameStatus = 'Scheduled';
            }
            if (gameStatus === 'In Progress') {
                const period = event.status.period || 0;
                const clock = event.status.displayClock || '0:00';
                if (league === 'NHL') { displayTime = `P${period} - ${clock}`; } 
                else if (league === 'NFL' || league === 'NCAAF' || league === 'NBA') { displayTime = `Q${period} - ${clock}`; } 
                else if (league === 'EPL') { displayTime = `${period}'`; } 
                else if (league === 'MLB') { displayTime = `Inning ${period}`; }
            } else if (gameStatus === 'Final') {
                const date = new Date(event.date);
                displayTime = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                statusText = statusText.includes('Final') ? 'Final' : statusText;
            } else {
                const date = new Date(event.date);
                displayTime = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                statusText = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            }
            const uniqueId = competition.id || event.id;
            return {
                id: `${league}-${uniqueId}`, 
                league: league,
                status: gameStatus,
                time: displayTime,
                homeTeam: home.team.shortDisplayName || home.team.displayName || home.team.abbreviation || 'Home',
                homeScore: parseInt(home.score) || 0,
                awayTeam: away.team.shortDisplayName || away.team.displayName || away.team.abbreviation || 'Away',
                awayScore: parseInt(away.score) || 0,
                followers: 0, 
                statusDetail: statusText,
            };
        }
        
        // ... (withExponentialBackoff is unchanged)
        async function withExponentialBackoff(fn, maxRetries = 5, delay = 1000) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    return await fn();
                } catch (error) {
                    if (i === maxRetries - 1) { throw error; }
                    const currentDelay = delay * Math.pow(2, i);
                    await new Promise(resolve => setTimeout(resolve, currentDelay));
                }
            }
        }
        
        // ... (fetchEspnScores is unchanged)
        async function fetchEspnScores() {
            let allGames = [];
            const datesToFetch = [
                { daysAgo: 0, label: 'Today' },
                { daysAgo: 1, label: 'Yesterday' },
                { daysAgo: 2, label: '2 Days Ago' }
            ];
            for (const dateConfig of datesToFetch) {
                const apiDate = getApiDate(dateConfig.daysAgo);
                for (const [league, baseUrl] of Object.entries(ESPN_ENDPOINTS)) {
                    const url = dateConfig.daysAgo > 0 ? `${baseUrl}?dates=${apiDate}` : baseUrl;
                    try {
                        await withExponentialBackoff(async () => {
                            const response = await fetch(url);
                            if (!response.ok) {
                                throw new Error(`HTTP error! status: ${response.status} for ${league} on ${dateConfig.label}`);
                            }
                            const data = await response.json();
                            if (data.events && Array.isArray(data.events)) {
                                const leagueGames = data.events
                                    .map(event => transformEspnGame(league, event))
                                    .filter(game => game !== null);
                                if (dateConfig.daysAgo > 0) {
                                    const finalGames = leagueGames.filter(g => g.status === 'Final');
                                    allGames.push(...finalGames);
                                } else {
                                    allGames.push(...leagueGames);
                                }
                            }
                        });
                    } catch (error) {
                        console.error(`Error fetching or processing ${league} data for ${dateConfig.label}:`, error);
                        fetchErrorCount++;
                        if (fetchErrorCount >= 10) {
                             showMessageBox("Critical Fetch Error", "Failed to load scores after multiple retries across dates. The API may be unavailable or have changed.");
                        }
                    }
                }
            }
            const uniqueGames = Array.from(new Map(allGames.map(game => [game.id, game])).values());
            fetchErrorCount = 0;
            gamesData = uniqueGames;
            renderFollowedGames();
            renderScores();
            renderAdminPanel();
        }


        // --- UI Rendering Functions ---
        
        // ... (renderGameCardFeed is unchanged)
        function renderGameCardFeed(game, isFollowed) {
            let borderColorClass = '';
            let statusText = game.status.toUpperCase();
            let statusColor = '';
            if (game.status === 'In Progress') {
                borderColorClass = 'border-red-500';
                statusText = 'LIVE';
                statusColor = 'text-green-600';
            } else if (game.status === 'Final') {
                borderColorClass = 'border-blue-500';
                statusColor = 'text-gray-500';
            } else {
                borderColorClass = 'border-gray-400';
                statusColor = 'text-blue-600';
            }
            let awayScoreClass = 'text-gray-700';
            let homeScoreClass = 'text-gray-700';
            if (game.status !== 'Scheduled') {
                if (game.awayScore > game.homeScore) {
                    awayScoreClass = 'text-red-600';
                } else if (game.homeScore > game.awayScore) {
                    homeScoreClass = 'text-red-600';
                }
            }
            const awayScoreDisplay = `<span class="text-3xl font-extrabold ${awayScoreClass}">${game.awayScore}</span>`;
            const homeScoreDisplay = game.status === 'Scheduled' 
                ? `<span class="text-sm font-medium text-gray-500">${game.statusDetail} @ ${game.time}</span>` 
                : `<span class="text-3xl font-extrabold ${homeScoreClass}">${game.homeScore}</span>`;
            const followButton = `<button data-game-id="${game.id}" data-action="${isFollowed ? 'unfollow' : 'follow'}" class="follow-btn text-xs font-semibold px-3 py-1 rounded-full ${isFollowed ? 'bg-red-500 text-white hover:bg-red-600' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'} transition duration-150">
                    ${isFollowed ? 'Following' : 'Follow'}
                </button>`;
            const detailLink = `<a href="#" data-game-id="${game.id}" class="detail-link text-blue-600 hover:text-blue-800 text-sm font-medium mt-2 block">View Details & Chat</a>`;
            const followerCount = gameMetadata[game.id]?.followerCount || 0;
            return `
                <div data-game-id="${game.id}" class="game-card bg-white p-6 rounded-xl shadow-lg border-t-4 ${borderColorClass} hover:shadow-2xl transition duration-300" style="cursor: pointer;">
                    <div class="flex justify-between items-start mb-4">
                        <span class="text-xs font-medium text-gray-500 bg-gray-100 px-3 py-1 rounded-full">${game.league}</span>
                        ${followButton}
                    </div>
                    <div class="space-y-4">
                        <div class="flex justify-between items-center border-b pb-2">
                            <div class="flex items-center space-x-3">
                                <span class="text-lg font-bold text-gray-800">${game.awayTeam}</span>
                            </div>
                            ${awayScoreDisplay}
                        </div>
                        <div class="flex justify-between items-center">
                            <div class="flex items-center space-x-3">
                                <span class="text-lg font-bold text-gray-800">${game.homeTeam}</span>
                            </div>
                            ${homeScoreDisplay}
                        </div>
                    </div>
                    <div class="mt-4 pt-4 border-t border-gray-100 flex justify-between items-center">
                        <span class="text-sm font-medium ${statusColor}">
                            ${statusText}
                            ${game.status !== 'Scheduled' && game.status !== 'Final' ? ' (' + game.time + ')' : ''}
                            ${game.status === 'Final' ? ' (' + game.time + ')' : ''}
                        </span>
                        <div class="text-xs text-gray-500 flex items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1 text-red-500" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-6-3a2 2 0 11-4 0 2 2 0 014 0zm-2 4a5 5 0 00-4.546 2.916A5.98 5.98 0 0010 16a5.979 5.979 0 004.546-2.084A5 5 0 0010 11z" clip-rule="evenodd" />
                            </svg>
                            ${followerCount} Following
                        </div>
                    </div>
                    ${detailLink}
                </div>
            `;
        }
        
        // ... (renderFollowedGameCardDashboard is unchanged)
        function renderFollowedGameCardDashboard(game) {
            let borderColorClass = 'border-red-500'; 
            let statusTextColor = 'text-red-600'; 
            let statusText = 'LIVE';
            if (game.status === 'Final') {
                borderColorClass = 'border-blue-500';
                statusTextColor = 'text-blue-600';
                statusText = 'FINAL';
            } else if (game.status === 'Scheduled') {
                borderColorClass = 'border-gray-400';
                statusTextColor = 'text-gray-600';
                statusText = 'UPCOMING';
            }
            const fullStatusText = game.status === 'In Progress' ? `LIVE (${game.time})` : statusText;
            let awayScoreClass = 'text-gray-900';
            let homeScoreClass = 'text-gray-900';
            if (game.status !== 'Scheduled') {
                if (game.awayScore > game.homeScore) {
                    awayScoreClass = 'text-red-600';
                } else if (game.homeScore > game.awayScore) {
                    homeScoreClass = 'text-red-600';
                }
            }
            let descriptionText = game.status === 'Scheduled' ? `${game.statusDetail} @ ${game.time}` : game.statusDetail;
            if (game.status === 'Final') {
                descriptionText = `Final (${game.time})`; 
            }
            const followerCount = gameMetadata[game.id]?.followerCount || 0;
            return `
                <div class="bg-white p-6 rounded-xl shadow-md border-l-4 ${borderColorClass} flex flex-col justify-between w-full sm:w-80 flex-shrink-0 hover:shadow-xl transition duration-150">
                    <div class="cursor-pointer dashboard-detail-link hover:bg-gray-50 p-2 -m-2 rounded-lg" data-game-id="${game.id}">
                        <div class="flex items-center mb-2">
                            <span class="text-xs font-extrabold tracking-wider uppercase ${statusTextColor}">${game.league} - ${fullStatusText}</span>
                        </div>
                        <div class="text-xl font-extrabold">
                            <p class="mb-1">
                                <span class="${awayScoreClass}">${game.awayTeam} ${game.awayScore}</span> vs. 
                                <span class="${homeScoreClass}">${game.homeScore} ${game.homeTeam}</span>
                            </p>
                        </div>
                        <div class="flex flex-col mt-2">
                            <span class="text-sm font-medium text-gray-500">${descriptionText}</span>
                            <div class="text-xs text-gray-500 flex items-center mt-1">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1 text-red-500" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-6-3a2 2 0 11-4 0 2 2 0 014 0zm-2 4a5 5 0 00-4.546 2.916A5.98 5.98 0 0010 16a5.979 5.979 0 004.546-2.084A5 5 0 0010 11z" clip-rule="evenodd" />
                                </svg>
                                ${followerCount} Following
                            </div>
                        </div>
                    </div>
                    <div class="flex justify-end pt-3 border-t border-gray-100 mt-2">
                        <button data-game-id="${game.id}" data-action="unfollow" class="follow-btn text-xs font-semibold px-3 py-1 rounded-full border border-gray-300 text-gray-700 hover:bg-gray-100 transition duration-150">
                            Unfollow
                        </button>
                    </div>
                </div>
            `;
        }

        // ... (renderFriendActivityFeed is unchanged)
        function renderFriendActivityFeed() {
            const container = document.getElementById('friend-activity-list');
            const activityListHtml = mockFriends.map(friend => {
                const dotColor = friend.color === 'green' ? 'bg-green-500' : friend.color === 'blue' ? 'bg-blue-500' : 'bg-gray-400';
                let detailLink;
                if (friend.status === 'Watching') {
                    detailLink = `<span class="text-xs font-semibold text-red-600">${friend.status} ${friend.detail}</span>`;
                } else if (friend.status === 'Browsing') {
                    detailLink = `<span class="text-xs font-semibold text-blue-600">${friend.status} ${friend.detail}</span>`;
                } else {
                    detailLink = `<span class="text-xs font-semibold text-gray-500">Offline</span>`;
                }
                return `
                    <div class="flex justify-between items-center py-3 border-b border-gray-100 last:border-b-0">
                        <div class="flex items-center space-x-3">
                            <span class="w-2 h-2 rounded-full ${dotColor}"></span>
                            <span class="text-base font-black text-gray-800">${friend.name}</span>
                        </div>
                        ${detailLink}
                    </div>
                `;
            }).join('');
            const html = `<div class="bg-white p-6 rounded-xl shadow-xl">${activityListHtml}</div>`;
            container.innerHTML = html;
        }

        // ... (renderScores is unchanged)
        function renderScores() {
            if (!isAuthReady) return; 
            const container = document.getElementById('scores-container');
            const filterLeague = document.getElementById('league-filter').value;
            const filterStatus = document.getElementById('status-filter').value;
            const searchQuery = document.getElementById('team-search').value.toLowerCase(); 
            let filteredGames = gamesData.filter(game => {
                const leagueMatch = filterLeague === 'All' || game.league === filterLeague;
                const statusMatch = filterStatus === 'All' || game.status === filterStatus;
                const searchMatch = !searchQuery || 
                                    game.homeTeam.toLowerCase().includes(searchQuery) ||
                                    game.awayTeam.toLowerCase().includes(searchQuery);
                return leagueMatch && statusMatch && searchMatch;
            });
            const statusOrder = { 'In Progress': 1, 'Scheduled': 2, 'Final': 3 };
            filteredGames.sort((a, b) => {
                const orderA = statusOrder[a.status] || 99;
                const orderB = statusOrder[b.status] || 99;
                if (orderA !== orderB) { return orderA - orderB; }
                return a.league.localeCompare(b.league);
            });
            container.innerHTML = filteredGames.map(game => {
                const isFollowed = !!followedGames[game.id]; 
                return renderGameCardFeed(game, isFollowed); 
            }).join('');
            document.querySelectorAll('.follow-btn').forEach(button => {
                button.removeEventListener('click', handleFollowToggle); 
                button.addEventListener('click', handleFollowToggle); 
            });
            document.querySelectorAll('.game-card').forEach(card => {
                card.removeEventListener('click', (e) => { 
                    e.preventDefault();
                    showGameDetail(e.currentTarget.dataset.gameId);
                });
                card.addEventListener('click', (e) => { 
                    if (e.target.closest('.follow-btn')) { return; }
                    e.preventDefault();
                    showGameDetail(e.currentTarget.dataset.gameId);
                });
            });
        }
        
        // ... (handleDashboardDetailClick is unchanged)
        function handleDashboardDetailClick(e) {
            const gameId = e.currentTarget.dataset.gameId;
            showGameDetail(gameId);
        }

        // ... (renderFollowedGames is unchanged)
        function renderFollowedGames() {
            if (!isAuthReady) return; 
            const container = document.getElementById('followed-games-container');
            const noGamesMessage = document.getElementById('no-followed-games');
            renderFriendActivityFeed(); 
            const followedList = gamesData.filter(game => followedGames[game.id]);
            if (followedList.length === 0) {
                noGamesMessage.classList.remove('hidden');
                container.innerHTML = '';
            } else {
                noGamesMessage.classList.add('hidden');
                container.innerHTML = followedList.map(game => renderFollowedGameCardDashboard(game)).join('');
                document.querySelectorAll('#followed-games-container .follow-btn').forEach(button => {
                    button.removeEventListener('click', handleFollowToggle); 
                    button.addEventListener('click', handleFollowToggle); 
                });
                document.querySelectorAll('.dashboard-detail-link').forEach(link => {
                    link.removeEventListener('click', handleDashboardDetailClick); 
                    link.addEventListener('click', handleDashboardDetailClick);
                });
            }
        }
        
        // ... (renderAdminPrompts is unchanged)
        function renderAdminPrompts() {
            if (unsubscribePromptsAdmin) {
                unsubscribePromptsAdmin();
            }
            const promptsColRef = getGamePromptsColRef(db);
            // FIX: Removed orderBy('createdAt', 'desc') to prevent index error
            const q = query(promptsColRef); 
            unsubscribePromptsAdmin = onSnapshot(q, (snapshot) => {
                const prompts = [];
                snapshot.forEach(doc => {
                    prompts.push({ id: doc.id, ...doc.data() });
                });
                
                // FIX: Sort in memory instead of in the query
                prompts.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
                
                const limitedPrompts = prompts.slice(0, 20); 
                const tbody = document.getElementById('admin-prompt-list');
                const noPromptsMessage = document.getElementById('no-prompts-message');
                tbody.innerHTML = ''; 
                if (limitedPrompts.length === 0) {
                    noPromptsMessage.classList.remove('hidden');
                } else {
                    noPromptsMessage.classList.add('hidden');
                }
                limitedPrompts.forEach(p => {
                    const row = tbody.insertRow();
                    row.className = `transition duration-150 ${p.isResolved ? 'bg-green-50' : 'bg-red-50 hover:bg-red-100'}`;
                    row.insertCell().textContent = p.gameId;
                    row.insertCell().textContent = p.question.substring(0, 50) + (p.question.length > 50 ? '...' : '');
                    const statusCell = row.insertCell();
                    statusCell.className = `font-bold ${p.isResolved ? 'text-green-700' : 'text-red-700'}`;
                    statusCell.textContent = p.isResolved ? 'Resolved' : 'Active';
                    row.insertCell().textContent = p.isResolved ? p.answer : 'N/A';
                    const actionCell = row.insertCell();
                    if (!p.isResolved) {
                        actionCell.innerHTML = `
                            <button data-id="${p.id}" data-answer="Yes" class="resolve-btn bg-green-500 text-white px-3 py-1 rounded-lg text-sm hover:bg-green-600 transition duration-150 mr-2">
                                Resolve Yes
                            </button>
                            <button data-id="${p.id}" data-answer="No" class="resolve-btn bg-red-500 text-white px-3 py-1 rounded-lg text-sm hover:bg-red-600 transition duration-150">
                                Resolve No
                            </button>
                        `;
                    } else {
                        actionCell.innerHTML = `
                            <span class="text-sm text-gray-600 mr-2">Actioned</span>
                            <button data-id="${p.id}" class="delete-btn bg-red-700 text-white px-3 py-1 rounded-lg text-sm hover:bg-red-800 transition duration-150">
                                Delete
                            </button>
                        `;
                    }
                });
                document.querySelectorAll('.resolve-btn').forEach(button => {
                    button.onclick = (e) => {
                        const id = e.target.dataset.id;
                        const answer = e.target.dataset.answer;
                        handleSetAnswer(id, answer);
                    };
                });
                document.querySelectorAll('.delete-btn').forEach(button => {
                    button.onclick = (e) => {
                        const id = e.target.dataset.id;
                        handleDeletePrompt(id);
                    };
                });
            }, (error) => {
                console.error("Firestore onSnapshot (Admin Prompts) error:", error);
            });
        }

        // ... (renderAdminPanel is unchanged)
        function renderAdminPanel() {
            if (!isAuthReady) return; 
            renderAdminPrompts(); 
            const tbody = document.getElementById('admin-game-list');
            tbody.innerHTML = ''; 
            gamesData.forEach(game => {
                const row = tbody.insertRow();
                row.className = 'hover:bg-gray-50 transition duration-150';
                row.insertCell().textContent = game.id;
                row.insertCell().textContent = game.league;
                row.insertCell().textContent = `${game.awayTeam} vs ${game.homeTeam}`;
                row.insertCell().textContent = game.status;
                row.insertCell().textContent = game.time;
                const scoreCell = row.insertCell();
                scoreCell.className = 'flex space-x-2 p-3';
                scoreCell.innerHTML = `
                    <input type="number" class="admin-input bg-gray-100 cursor-not-allowed" value="${game.homeScore}" readonly title="API data is read-only">
                    <input type="number" class="admin-input bg-gray-100 cursor-not-allowed" value="${game.awayScore}" readonly title="API data is read-only">
                `;
                const actionCell = row.insertCell();
                actionCell.innerHTML = `
                    <button class="bg-gray-500 text-white px-3 py-1 rounded-lg text-sm opacity-50 cursor-not-allowed" disabled>
                        Save
                    </button>
                `;
            });
        }
        
        // ... (handleNewPrompt is unchanged)
        async function handleNewPrompt() {
            if (!isAuthReady) {
                showMessageBox("Error", "Authentication not ready.");
                return;
            }
            const gameId = document.getElementById('prompt-game-id').value.trim();
            const question = document.getElementById('prompt-question').value.trim();
            if (!gameId || !question) {
                showMessageBox("Input Required", "Please enter both a valid Game ID and a Question.");
                return;
            }
            const promptsColRef = getGamePromptsColRef(db);
            const activeQuery = query(promptsColRef, where('gameId', '==', gameId), where('isResolved', '==', false));
            try {
                const activeSnapshot = await getDocs(activeQuery);
                if (!activeSnapshot.empty) {
                    showMessageBox("Existing Prompt Active", `There is already an active prompt for game ${gameId}. Please resolve the current one before creating a new one.`);
                    return;
                }
                const newPrompt = {
                    gameId: gameId,
                    question: question,
                    createdAt: new Date().toISOString(),
                    userId: userId,
                    isResolved: false,
                    answer: null,
                    resolvedAt: null,
                    yesCount: 0,
                    noCount: 0
                };
                await addDoc(promptsColRef, newPrompt);
                document.getElementById('prompt-question').value = '';
                showMessageBox("Prompt Created", `New live question successfully created for game ${gameId}!`);
            } catch (error) {
                console.error("Error sending new prompt:", error);
                showMessageBox("Prompt Error", `Failed to create prompt. Error: ${error.message}`);
            }
        }
        
        // ... (handleSetAnswer is unchanged)
        async function handleSetAnswer(promptId, answer) {
            if (!isAuthReady) {
                showMessageBox("Error", "Authentication not ready.");
                return;
            }
            const promptDocRef = doc(getGamePromptsColRef(db), promptId);
            try {
                const promptSnap = await getDoc(promptDocRef);
                if (!promptSnap.exists()) {
                    showMessageBox("Error", "Prompt not found. Cannot update scores.");
                    return;
                }
                const gameId = promptSnap.data().gameId;
                await updateDoc(promptDocRef, {
                    isResolved: true,
                    answer: answer,
                    resolvedAt: new Date().toISOString()
                });
                showMessageBox("Prompt Resolved", `The prompt has been resolved with answer: ${answer}. Updating scores...`);
                const votesColRef = getPromptVotesColRef(db, promptId);
                const votesSnapshot = await getDocs(votesColRef);
                if (votesSnapshot.empty) {
                    console.log("No votes to update for this prompt.");
                    return; 
                }
                const userIds = votesSnapshot.docs.map(d => d.id);
                const nicknameMap = new Map();
                const MAX_IN_QUERIES = 30;
                const profilesColRef = getUserPublicProfileColRef(db);
                for (let i = 0; i < userIds.length; i += MAX_IN_QUERIES) {
                    const batchUserIds = userIds.slice(i, i + MAX_IN_QUERIES);
                    const profilesQuery = query(profilesColRef, where('userId', 'in', batchUserIds));
                    const profilesSnapshot = await getDocs(profilesQuery);
                    profilesSnapshot.forEach(doc => {
                        nicknameMap.set(doc.id, doc.data().nickname);
                    });
                }
                console.log("Fetched nicknames for voters:", nicknameMap);
                const scoreBatch = writeBatch(db);
                const leaderboardColRef = getLeaderboardColRef(db, gameId); 
                votesSnapshot.forEach(voteDoc => {
                    const userId = voteDoc.id;
                    const userVote = voteDoc.data().vote;
                    const isCorrect = userVote === answer;
                    const scoreIncrementVal = isCorrect ? 1 : 0;
                    const correctIncrementVal = isCorrect ? 1 : 0;
                    const incorrectIncrementVal = isCorrect ? 0 : 1;
                    const username = nicknameMap.get(userId) || `User...${userId.substring(userId.length - 4)}`;
                    const userLeaderboardDocRef = doc(leaderboardColRef, userId);
                    scoreBatch.set(userLeaderboardDocRef, {
                        score: increment(scoreIncrementVal),
                        correct: increment(correctIncrementVal),
                        incorrect: increment(incorrectIncrementVal),
                        username: username 
                    }, { merge: true });
                });
                await scoreBatch.commit();
                console.log(`Successfully updated scores for ${votesSnapshot.size} users for game ${gameId}.`);
            } catch (error) {
                console.error(`Error resolving prompt or updating scores ${promptId}:`, error);
                showMessageBox("Score Update Error", `Failed to update scores. Error: ${error.message}`);
            }
        }
        
        // ... (handleDeletePrompt is unchanged)
        async function handleDeletePrompt(promptId) {
            if (!isAuthReady) {
                showMessageBox("Error", "Authentication not ready.");
                return;
            }
            console.log(`Attempting to delete prompt: ${promptId}`);
            const promptDocRef = doc(getGamePromptsColRef(db), promptId);
            const votesColRef = getPromptVotesColRef(db, promptId);
            try {
                const votesSnapshot = await getDocs(votesColRef);
                if (!votesSnapshot.empty) {
                    const batch = writeBatch(db);
                    votesSnapshot.docs.forEach(voteDoc => {
                        batch.delete(voteDoc.ref);
                    });
                    await batch.commit();
                    console.log(`Deleted ${votesSnapshot.size} votes for prompt ${promptId}.`);
                }
                await deleteDoc(promptDocRef);
                showMessageBox("Prompt Deleted", `The prompt and all its associated votes have been deleted.`);
            } catch (error) {
                console.error(`Error deleting prompt ${promptId}:`, error);
                showMessageBox("Delete Error", `Failed to delete prompt. Error: ${error.message}`);
            }
        }
        
        /**
         * START: NEW Admin function to clear an entire leaderboard for a game.
         */
        async function handleClearLeaderboard() {
            if (!isAuthReady || !auth.currentUser || auth.currentUser.email !== ADMIN_EMAIL) {
                showMessageBox("Access Denied", "You do not have permission to perform this action.");
                return;
            }

            const gameId = document.getElementById('clear-leaderboard-game-id').value.trim();
            if (!gameId) {
                showMessageBox("Input Required", "Please enter a Game ID to clear its leaderboard.");
                return;
            }

            // Show a confirmation box first
            showConfirmBox(
                "Confirm Leaderboard Deletion",
                `Are you sure you want to permanently delete ALL scores for Game ID: ${gameId}? This cannot be undone.`,
                async () => {
                    // This code runs if the admin clicks "Confirm"
                    console.log(`Admin confirmed deletion for leaderboard: ${gameId}`);
                    try {
                        const leaderboardColRef = getLeaderboardColRef(db, gameId);
                        const scoresSnapshot = await getDocs(leaderboardColRef);

                        if (scoresSnapshot.empty) {
                            showMessageBox("Leaderboard Empty", `The leaderboard for ${gameId} is already empty.`);
                            document.getElementById('clear-leaderboard-game-id').value = '';
                            return;
                        }

                        const batch = writeBatch(db);
                        scoresSnapshot.docs.forEach(doc => {
                            batch.delete(doc.ref);
                        });

                        await batch.commit();

                        console.log(`Successfully deleted ${scoresSnapshot.size} score documents for game ${gameId}.`);
                        showMessageBox("Success", `Successfully cleared the leaderboard for ${gameId}. ${scoresSnapshot.size} entries were deleted.`);
                        document.getElementById('clear-leaderboard-game-id').value = '';

                    } catch (error) {
                        console.error(`Error clearing leaderboard for ${gameId}:`, error);
                        showMessageBox("Delete Error", `Failed to clear leaderboard. Error: ${error.message}`);
                    }
                }
            );
        }
        /**
         * END: NEW Admin function
         */

        /**
         * NEW: Gated vote function.
         */
        async function handleVote(promptId, vote, currentUserId) {
            // NEW: Check if user is anonymous (guest)
            if (isAnonymous) {
                showMessageBox("Login Required", "Please create an account or log in to vote.");
                return;
            }
            if (!currentUserId) {
                showMessageBox("Error", "Authentication is required to vote.");
                return;
            }

            const promptDocRef = doc(getGamePromptsColRef(db), promptId);
            const voteDocRef = doc(getPromptVotesColRef(db, promptId), currentUserId);
            
            try {
                const voteSnapshot = await getDoc(voteDocRef); 
                if (voteSnapshot.exists()) {
                    showMessageBox("Already Voted", `You have already voted '${voteSnapshot.data().vote}' on this question.`);
                    return;
                }
                const batch = writeBatch(db);
                if (vote === 'Yes') {
                    batch.update(promptDocRef, { yesCount: increment(1) });
                } else if (vote === 'No') {
                    batch.update(promptDocRef, { noCount: increment(1) });
                } else {
                    showMessageBox("Error", "Invalid vote option.");
                    return;
                }
                batch.set(voteDocRef, { vote: vote, timestamp: new Date().toISOString() });
                await batch.commit();
            } catch (error) {
                console.error("Error committing vote batch:", error);
                showMessageBox("Vote Error", `Failed to record your vote. Error: ${error.message}`);
            }
        }
        
        // ... (handleSaveNickname is MODIFIED)
        async function handleSaveNickname(event) { // NEW: added event
            if (!isAuthReady || !userId) {
                showMessageBox("Error", "You must be logged in to save a nickname.");
                return;
            }
            // NEW: Also check for anonymous
            if (isAnonymous) {
                 showMessageBox("Login Required", "You must have a real account to set a nickname.");
                return;
            }
            
            // NEW: Determine which input to read from
            let newName = '';
            // const nicknameInputDashboard = document.getElementById('nickname-input'); // No longer needed
            const nicknameInputAccount = document.getElementById('nickname-input-account');

            // Only read from the account input
            newName = nicknameInputAccount.value.trim();
            
            // If one field was used, update the other one to match
            // if (newName) {
            //     nicknameInputDashboard.value = newName; // No longer exists
            // }

            if (newName.length < 3) {
                showMessageBox("Nickname Too Short", "Your nickname must be at least 3 characters long.");
                return;
            }
            if (newName.length > 20) {
                showMessageBox("Nickname Too Long", "Your nickname must be 20 characters or less.");
                return;
            }
            const profileDocRef = getUserPublicProfileDocRef(db, userId);
            try {
                await setDoc(profileDocRef, { 
                    nickname: newName,
                    userId: userId 
                }, { merge: true });
                showMessageBox("Nickname Saved", `Your public nickname is now set to: ${newName}`);
            } catch (error) {
                console.error("Error saving nickname:", error);
                showMessageBox("Save Error", `Failed to save nickname. Error: ${error.message}`);
            }
        }

        /**
         * NEW: Handles password change
         */
        async function handleChangePassword() {
            if (!isAuthReady || !auth.currentUser || isAnonymous) {
                showMessageBox("Error", "You must be logged in with a full account to change your password.");
                return;
            }

            const currentPassword = document.getElementById('current-password').value;
            const newPassword = document.getElementById('new-password').value;
            const confirmNewPassword = document.getElementById('confirm-new-password').value;

            if (!currentPassword || !newPassword || !confirmNewPassword) {
                showMessageBox("Input Required", "Please fill in all password fields.");
                return;
            }
            if (newPassword.length < 6) {
                showMessageBox("Password Too Short", "Your new password must be at least 6 characters long.");
                return;
            }
            if (newPassword !== confirmNewPassword) {
                showMessageBox("Passwords Mismatch", "Your new passwords do not match.");
                return;
            }

            const user = auth.currentUser;
            if (!user.email) {
                 showMessageBox("Error", "Cannot re-authenticate user without an email. This operation is not supported for this account type.");
                return;
            }

            try {
                // 1. Re-authenticate the user
                const credential = EmailAuthProvider.credential(user.email, currentPassword);
                await reauthenticateWithCredential(user, credential);
                
                // 2. Update the password
                await updatePassword(user, newPassword);
                
                // 3. Success
                showMessageBox("Success", "Your password has been updated. Please log in again.");
                
                // Clear fields
                document.getElementById('current-password').value = '';
                document.getElementById('new-password').value = '';
                document.getElementById('confirm-new-password').value = '';
                
                // Log the user out
                await handleSignOut();

            } catch (error) {
                console.error("Password Change Error:", error);
                let a = "Failed to change password. Please check your *current* password and try again.";
                if (error.code === 'auth/wrong-password') {
                     a = "Failed to change password. The *current* password you entered is incorrect.";
                } else if (error.code === 'auth/too-many-requests') {
                     a = "Too many attempts. Please try again later.";
                }
                showMessageBox("Password Change Failed", a);
            }
        }

        /**
         * NEW: Handles account deletion
         */
        async function handleDeleteAccount() {
             if (!isAuthReady || !auth.currentUser || isAnonymous) {
                showMessageBox("Error", "You must be logged in with a full account to delete it.");
                return;
            }

            const password = document.getElementById('delete-account-password').value;
            if (!password) {
                showMessageBox("Password Required", "Please enter your password to confirm account deletion.");
                return;
            }

            const user = auth.currentUser;
             if (!user.email) {
                 showMessageBox("Error", "Cannot re-authenticate user without an email. This operation is not supported for this account type.");
                return;
            }

            try {
                // 1. Re-authenticate
                const credential = EmailAuthProvider.credential(user.email, password);
                await reauthenticateWithCredential(user, credential);
                
                // --- NEW: Get user ID *before* deleting ---
                const userIdToDelete = user.uid;

                // --- NEW: Robust Deletion Logic ---
                // Get the user's profile to see which games they followed
                const profileDocRef = getUserPublicProfileDocRef(db, userIdToDelete);
                const profileSnap = await getDoc(profileDocRef);
                
                let gamesToDecrement = [];
                if (profileSnap.exists() && profileSnap.data().following) {
                    gamesToDecrement = Object.keys(profileSnap.data().following);
                }

                const batch = writeBatch(db);

                // 1. Decrement metadata for each followed game
                if (gamesToDecrement.length > 0) {
                    const metadataColRef = getGameMetadataColRef(db);
                    console.log(`Decrementing ${gamesToDecrement.length} game followers for user ${userIdToDelete}`);
                    for (const gameId of gamesToDecrement) {
                        const gameMetadataDocRef = doc(metadataColRef, gameId);
                        // Use set with merge to handle potential -1 on a non-existent doc gracefully
                        batch.set(gameMetadataDocRef, { followerCount: increment(-1) }, { merge: true });
                    }
                }

                // 2. Delete the user's public profile
                if (profileSnap.exists()) {
                    batch.delete(profileDocRef);
                }
                
                // 3. (Cleanup) Attempt to delete the old private followed_games doc just in case it exists
                // We define the path manually here since we removed the helper function
                let oldFollowedGamesDocRef;
                if (appId === 'default-app-id') {
                    oldFollowedGamesDocRef = doc(db, 'users', userIdToDelete, 'followed_games', 'user_follows');
                } else {
                    oldFollowedGamesDocRef = doc(db, 'artifacts', appId, 'users', userIdToDelete, 'followed_games', 'user_follows');
                }
                if (oldFollowedGamesDocRef) {
                    batch.delete(oldFollowedGamesDocRef);
                }

                // Commit all Firestore changes
                await batch.commit();
                console.log(`Successfully cleared Firestore data for user ${userIdToDelete}`);

                // 4. Delete the user's Auth record (only after Firestore is done)
                await deleteUser(user);
                
                // 5. Success
                showMessageBox("Account Deleted", "Your account and all associated data have been permanently deleted. We're sorry to see you go.");
                // User will be signed out automatically, onAuthStateChanged will handle the rest.
                document.getElementById('delete-account-password').value = '';


            } catch (error) {
                console.error("Account Deletion Error:", error);
                let a = "Failed to delete account. Please check your password and try again.";
                if (error.code === 'auth/wrong-password') {
                     a = "Failed to delete account. The password you entered is incorrect.";
                } else if (error.code === 'auth/too-many-requests') {
                     a = "Too many attempts. Please try again later.";
                } else if (error.code === 'firestore/permission-denied') {
                    a = "Failed to delete account data due to permissions. The account itself may or may not have been deleted.";
                }
                showMessageBox("Deletion Failed", a);
            }
        }


        // --- Filter and UI Helper Functions ---
        
        // ... (populateLeagueFilter is unchanged)
        function populateLeagueFilter() {
            const filter = document.getElementById('league-filter');
            const uniqueLeagues = ['All', ...new Set(Object.keys(ESPN_ENDPOINTS))];
            if (filter.options.length === 0 || filter.options.length !== uniqueLeagues.length) {
                filter.innerHTML = uniqueLeagues.map(league => 
                    `<option value="${league}">${league}</option>`
                ).join('');
            }
            filter.removeEventListener('change', renderScores);
            filter.addEventListener('change', renderScores);
            document.getElementById('status-filter').removeEventListener('change', renderScores);
            document.getElementById('status-filter').addEventListener('change', renderScores);
            const searchInput = document.getElementById('team-search');
            if (searchInput) {
                 searchInput.removeEventListener('input', renderScores);
                 searchInput.addEventListener('input', renderScores);
            }
        }
        
        // ... (renderGamePrompt is MODIFIED)
        async function renderGamePrompt(promptToDisplay) {
            const container = document.getElementById('live-prompt-container');
            const textEl = document.getElementById('prompt-text');
            const answerBox = document.getElementById('prompt-answer-box');
            const answerResult = document.getElementById('prompt-answer-result');
            const resolvedUser = document.getElementById('prompt-resolved-user');
            const votingSection = document.getElementById('voting-section');
            const votingExtraInfo = document.getElementById('voting-extra-info'); // <-- ADDED
            
            answerBox.classList.add('hidden');
            container.classList.remove('bg-red-50', 'border-red-500', 'bg-green-50', 'border-green-500');
            container.classList.add('bg-gray-50', 'border-gray-300'); 
            votingSection.innerHTML = ''; 
            if (votingExtraInfo) votingExtraInfo.innerHTML = ''; // <-- ADDED (The Fix)

            if (promptToDisplay) {
                textEl.textContent = promptToDisplay.question;
                if (promptToDisplay.isResolved) {
                    answerBox.classList.remove('hidden');
                    answerResult.textContent = promptToDisplay.answer;
                    const answerColor = promptToDisplay.answer === 'Yes' ? 'bg-green-600' : 'bg-red-600';
                    answerResult.className = `text-white ${answerColor} text-3xl font-extrabold px-4 py-2 rounded-lg inline-block shadow-md`;
                    const time = new Date(promptToDisplay.resolvedAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                    resolvedUser.textContent = `Resolved to ${promptToDisplay.answer} at ${time}`;
                    container.classList.remove('bg-gray-50', 'border-gray-300');
                    container.classList.add('bg-green-50', 'border-green-500');
                    const totalVotes = promptToDisplay.yesCount + promptToDisplay.noCount;
                    const yesPct = totalVotes > 0 ? ((promptToDisplay.yesCount / totalVotes) * 100).toFixed(0) : 0;
                    const noPct = totalVotes > 0 ? ((promptToDisplay.noCount / totalVotes) * 100).toFixed(0) : 0;
                    votingSection.innerHTML = `
                        <div class="flex flex-col items-center p-3 rounded-xl bg-gray-100 w-full shadow-inner">
                            <p class="text-sm font-bold text-gray-700 mb-2">FINAL VOTE TALLY</p>
                            <p class="text-xs text-gray-500 mb-3">${totalVotes} total votes recorded.</p>
                            <div class="w-full flex justify-around space-x-4">
                                <div class="flex flex-col items-center p-2 rounded-lg bg-white w-1/2">
                                    <span class="text-4xl font-black text-green-600">${yesPct}%</span>
                                    <span class="text-sm font-semibold text-gray-700">YES</span>
                                </div>
                                <div class="flex flex-col items-center p-2 rounded-lg bg-white w-1/2">
                                    <span class="text-4xl font-black text-red-600">${noPct}%</span>
                                    <span class="text-sm font-semibold text-gray-700">NO</span>
                                </div>
                            </div>
                        </div>
                    `;
                } else {
                    container.classList.remove('bg-gray-50', 'border-gray-300');
                    container.classList.add('bg-red-50', 'border-red-500');
                    let userVote = null;
                    try {
                        const voteDocRef = doc(getPromptVotesColRef(db, promptToDisplay.id), userId);
                        const voteSnap = await getDoc(voteDocRef);
                        if (voteSnap.exists()) {
                            userVote = voteSnap.data().vote;
                        }
                    } catch (error) {
                        console.warn("Could not retrieve user vote status:", error);
                    }
                    const disableClass = userVote ? 'opacity-50 cursor-not-allowed' : 'hover:shadow-lg hover:scale-[1.02]';
                    const yesButtonClass = userVote === 'Yes' ? 'border-4 border-green-600 shadow-xl' : 'border-4 border-transparent';
                    const noButtonClass = userVote === 'No' ? 'border-4 border-red-600 shadow-xl' : 'border-4 border-transparent';
                    const totalVotes = promptToDisplay.yesCount + promptToDisplay.noCount;
                    votingSection.innerHTML = `
                        <button id="vote-yes-btn" data-vote="Yes" 
                            class="vote-btn flex-1 bg-green-500 text-white font-extrabold py-3 rounded-xl transition duration-150 ${disableClass} ${yesButtonClass}"
                            ${userVote ? 'disabled' : ''}>
                            YES <span class="text-sm font-medium ml-1">(${promptToDisplay.yesCount})</span>
                        </button>
                        <button id="vote-no-btn" data-vote="No"
                            class="vote-btn flex-1 bg-red-500 text-white font-extrabold py-3 rounded-xl transition duration-150 ${disableClass} ${noButtonClass}"
                            ${userVote ? 'disabled' : ''}>
                            NO <span class="text-sm font-medium ml-1">(${promptToDisplay.noCount})</span>
                        </button>
                    `;
                    document.querySelectorAll('.vote-btn').forEach(button => {
                        button.onclick = (e) => {
                            if (!userVote) {
                                handleVote(promptToDisplay.id, e.currentTarget.dataset.vote, userId);
                            } else {
                                showMessageBox("Already Voted", `You already chose ${userVote}. You must wait for the prompt to be resolved.`);
                            }
                        };
                    });
                    if (userVote) {
                         // MODIFIED: Insert into the new wrapper
                         if (votingExtraInfo) votingExtraInfo.innerHTML += ` 
                            <p class="text-center text-sm text-gray-500 font-medium">
                                You voted: <span class="font-bold text-${userVote === 'Yes' ? 'green' : 'red'}-600">${userVote}</span>. Waiting for resolution.
                            </p>
                        `;
                    }
                    if (totalVotes > 0) {
                        const yesPct = ((promptToDisplay.yesCount / totalVotes) * 100).toFixed(0);
                        const noPct = ((promptToDisplay.noCount / totalVotes) * 100).toFixed(0);
                         // MODIFIED: Insert into the new wrapper
                        if (votingExtraInfo) votingExtraInfo.innerHTML += `
                            <div class="w-full">
                                <p class="text-xs text-gray-500 mb-1 font-bold">LIVE TALLY: ${totalVotes} Votes</p>
                                <div class="flex h-3 rounded-full overflow-hidden bg-red-200 shadow-inner">
                                    <div style="width: ${yesPct}%" class="bg-green-500 transition-all duration-500 ease-out"></div>
                                </div>
                                <div class="flex justify-between text-xs font-semibold mt-1">
                                    <span class="text-green-600">${yesPct}% Yes</span>
                                    <span class="text-red-600">${noPct}% No</span>
                                </div>
                            </div>
                        `;
                    }
                }
            } else {
                textEl.textContent = "Waiting for a live question...";
            }
        }

        // ... (showGameDetail is MODIFIED, except for the query fix)
        function showGameDetail(gameId) {
            const game = gamesData.find(g => g.id === gameId);
            if (!game) {
                showMessageBox("Game Not Found", "The requested game detail could not be loaded.");
                return;
            }
            switchView('detail');
            const detailContent = document.getElementById('detail-content');
            detailContent.innerHTML = `
                <div class="flex flex-col items-center text-center">
                    <span class="text-sm font-semibold text-red-500 bg-red-100 px-3 py-1 rounded-full mb-4">${game.league}</span>
                    <h3 class="text-5xl font-black text-gray-900 mb-8">
                        ${game.awayTeam} <span class="text-gray-400 font-normal mx-4">@</span> ${game.homeTeam}
                    </h3>
                    <div class="flex space-x-8 items-center bg-gray-50 p-6 rounded-xl shadow-inner w-full max-w-lg">
                        <div class="flex-1">
                            <p class="text-xl font-semibold text-gray-600">${game.awayTeam}</p>
                            <p class="text-6xl font-extrabold text-gray-900">${game.awayScore}</p>
                        </div>
                        <div class="text-center">
                            <p class="text-lg font-bold ${game.status === 'In Progress' ? 'text-green-600' : 'text-gray-500'}">
                                ${game.time}
                            </p>
                            <p class="text-xs text-gray-500">${game.statusDetail}</p>
                        </div>
                        <div class="flex-1">
                            <p class="text-xl font-semibold text-gray-600">${game.homeTeam}</p>
                            <p class="text-6xl font-extrabold text-gray-900">${game.homeScore}</p>
                        </div>
                    </div>
                    <div id="live-prompt-container" class="mt-6 p-4 border-l-4 rounded-lg shadow-inner w-full max-w-lg transition duration-300 bg-gray-50 border-gray-300">
                        <p class="text-sm font-semibold mb-1 text-gray-700">LIVE YES/NO PROMPT:</p>
                        <p id="prompt-text" class="text-xl font-black text-gray-900">Waiting for a live question...</p>

                        <div id="voting-section" class="mt-4 pt-4 border-t border-gray-100 flex justify-center space-x-4">
                        </div>
                        <!-- NEW WRAPPER -->
                        <div id="voting-extra-info" class="mt-2 space-y-2"></div>

                        <div id="prompt-answer-box" class="mt-4 pt-3 border-t border-gray-200 hidden">
                            <p class="text-sm font-medium text-gray-500 mb-2">RESULT:</p>
                            <span id="prompt-answer-result" class="text-3xl font-extrabold px-4 py-2 rounded-full"></span>
                            <p id="prompt-resolved-user" class="text-xs text-gray-400 mt-2"></p>
                        </div>
                    </div>
                    <h4 class="text-2xl font-bold mt-8 text-gray-700">Live Play-by-Play & Chat (Mock)</h4>
                    <p class="text-gray-500 mt-2">
                        Game data is live! The full play-by-play and chat features would integrate here.
                    </p>
                    <div id="leaderboard-container" class="mt-8 w-full max-w-lg">
                        <h4 class="text-2xl font-bold text-gray-700 text-center">Game Leaderboard</h4>
                        <div id="leaderboard-list" class="mt-4 bg-white p-4 rounded-lg shadow-md border">
                            <p id="leaderboard-loading" class="text-center text-gray-500">Loading leaderboard...</p>
                        </div>
                    </div>
                </div>
            `;
            if (unsubscribePromptListener) {
                unsubscribePromptListener();
                unsubscribePromptListener = null;
                console.log("Stopped game prompt listener.");
            }
            const promptsColRef = getGamePromptsColRef(db);
            // FIX from user feedback: Removed orderBy to prevent index error
            const q = query(
                promptsColRef, 
                where('gameId', '==', gameId)
            );
            unsubscribePromptListener = onSnapshot(q, (snapshot) => {
                const allPrompts = [];
                snapshot.forEach(doc => {
                    allPrompts.push({ id: doc.id, ...doc.data() });
                });
                // Sort in memory
                allPrompts.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
                
                const activePrompt = allPrompts.find(p => p.isResolved === false);
                const latestResolvedPrompt = allPrompts.find(p => p.isResolved === true);
                
                // --- START: MODIFICATION PER USER REQUEST ---
                let promptToDisplay = activePrompt || latestResolvedPrompt;

                // Per your request: When a new prompt is created (activePrompt exists),
                // we will first "delete" the old resolved prompt's UI by
                // clearing the container, and then render the new active prompt.
                if (activePrompt) {
                    // 1. "Delete" the old UI (by rendering null, which shows "Waiting...")
                    renderGamePrompt(null);
                    
                    // 2. Use a brief timeout to allow the UI to clear
                    //    before rendering the new active prompt.
                    setTimeout(() => {
                        // Re-check: only render if the active prompt is still the one we expect
                        // This prevents a race condition if the prompt is resolved *very* quickly
                        if (document.getElementById('prompt-text').textContent === "Waiting for a live question...") {
                             renderGamePrompt(activePrompt);
                        }
                    }, 100); // 100ms delay to make the transition clear
                } else {
                    // No active prompt, so just show the latest resolved one or "Waiting..."
                    renderGamePrompt(promptToDisplay);
                }
                // --- END: MODIFICATION PER USER REQUEST ---

            }, (error) => {
                console.error("Prompt listener error:", error);
            });
            if (unsubscribeLeaderboardListener) {
                unsubscribeLeaderboardListener(); 
            }
            const leaderboardColRef = getLeaderboardColRef(db, gameId);
            const q_leaderboard = query(leaderboardColRef, orderBy('score', 'desc'));
            unsubscribeLeaderboardListener = onSnapshot(q_leaderboard, (snapshot) => {
                const players = [];
                snapshot.forEach(doc => {
                    players.push({ id: doc.id, ...doc.data() });
                });
                const leaderboardList = document.getElementById('leaderboard-list');
                if (snapshot.empty) {
                    leaderboardList.innerHTML = `<p class="text-center text-gray-500">No scores yet. Be the first to play!</p>`;
                } else {
                    leaderboardList.innerHTML = players.map((player, index) => {
                        const rankColor = index === 0 ? 'text-red-600' : index === 1 ? 'text-blue-600' : index === 2 ? 'text-green-600' : 'text-gray-900';
                        const score = player.score || 0;
                        const correct = player.correct || 0;
                        const incorrect = player.incorrect || 0;
                        const displayName = player.username || `User...${player.id.substring(player.id.length - 4)}`;
                        return `
                            <div class="flex justify-between items-center py-2 border-b last:border-b-0">
                                <div class="flex items-center">
                                    <span class="font-bold ${rankColor} w-6 text-center">#${index + 1}</span>
                                    <span class="text-gray-700 ml-2 font-medium">${displayName}</span>
                                </div>
                                <div class="text-right">
                                    <span class="font-bold text-lg text-red-600">${score} pts</span>
                                    <span class="text-xs text-gray-500 block">(${correct}C / ${incorrect}W)</span>
                                </div>
                            </div>
                        `;
                    }).join('');
                }
            }, (error) => {
                console.error("Leaderboard listener error:", error);
                const leaderboardList = document.getElementById('leaderboard-list');
                leaderboardList.innerHTML = `<p class="text-center text-red-500">Error loading leaderboard.</p>`;
            });
        }
        
        /**
         * NEW: Gated follow function.
         */
        async function handleFollowToggle(e) {
            // NEW: Check if user is anonymous (guest)
            if (isAnonymous) {
                showMessageBox("Login Required", "Please create an account or log in to follow games.");
                return;
            }
            if (!userId) {
                showMessageBox("Authentication Error", "Please wait for user authentication to complete before following games.");
                return;
            }

            const button = e.target;
            const gameId = button.dataset.gameId;
            const action = button.dataset.action;
            // MODIFIED: Get the public profile doc ref, which now holds the 'following' map
            const userDocRef = getUserPublicProfileDocRef(db, userId);
            // const newFollowedGames = { ...followedGames }; // No longer needed
            const metadataColRef = getGameMetadataColRef(db);
            const gameMetadataDocRef = doc(metadataColRef, gameId);
            const batch = writeBatch(db);
            let updateSuccess = false;

            if (action === 'follow') {
                // MODIFIED: Use dot notation to update a field in the map
                batch.update(userDocRef, { [`following.${gameId}`]: true });
                batch.set(gameMetadataDocRef, { followerCount: increment(1) }, { merge: true });
                updateSuccess = true;
                
            } else if (action === 'unfollow') {
                // MODIFIED: Use dot notation and deleteField to remove a field from the map
                batch.update(userDocRef, { [`following.${gameId}`]: deleteField() });
                batch.set(gameMetadataDocRef, { followerCount: increment(-1) }, { merge: true });
                updateSuccess = true;
            }
            
            if (updateSuccess) {
                try {
                    await batch.commit();
                } catch (error) {
                    console.error("Error committing batch update for follow toggle: ", error);
                    showMessageBox("Save Error", `Failed to update follow status and public counter. Error: ${error.message}`);
                }
            }
        }

        // --- View Switching and Initialization ---

        function switchView(view) {
            // Hide all main views
            document.getElementById('auth-view').classList.add('hidden'); // NEW
            document.getElementById('dashboard-view').classList.add('hidden');
            document.getElementById('scores-view').classList.add('hidden');
            document.getElementById('admin-view').classList.add('hidden');
            document.getElementById('detail-view').classList.add('hidden');
            document.getElementById('account-view').classList.add('hidden'); // NEW
            
            // Cleanup listeners when switching away
            if (unsubscribePromptListener) {
                unsubscribePromptListener();
                unsubscribePromptListener = null;
                console.log("Stopped game prompt listener.");
            }
            if (unsubscribeLeaderboardListener) {
                unsubscribeLeaderboardListener();
                unsubscribeLeaderboardListener = null;
                console.log("Stopped leaderboard listener.");
            }
            if (view !== 'admin' && unsubscribePromptsAdmin) {
                 unsubscribePromptsAdmin();
                 unsubscribePromptsAdmin = null;
                 console.log("Stopped admin prompt listener.");
            }

            // Show the selected view
            let highlightedView = view;
            if (view === 'auth') {
                document.getElementById('auth-view').classList.remove('hidden');
                highlightedView = ''; // No nav link for auth
            } else if (view === 'detail') {
                 document.getElementById('detail-view').classList.remove('hidden');
                 highlightedView = 'scores'; // Highlight 'scores' as the parent
            } else if (view === 'dashboard') {
                document.getElementById('dashboard-view').classList.remove('hidden');
                renderFollowedGames();
            } else if (view === 'scores') {
                document.getElementById('scores-view').classList.remove('hidden');
                populateLeagueFilter(); 
                renderScores();
            } else if (view === 'admin') {
                // NEW: Check for admin privileges
                if (auth.currentUser && auth.currentUser.email === ADMIN_EMAIL) {
                    document.getElementById('admin-view').classList.remove('hidden');
                    renderAdminPanel();
                } else {
                    // Not an admin, redirect
                    console.warn("Access Denied: User is not authorized for Admin Panel.");
                    showMessageBox("Access Denied", "You do not have permission to view this page.");
                    
                    if (isAnonymous) {
                        document.getElementById('scores-view').classList.remove('hidden'); // Show scores view
                        highlightedView = 'scores'; // Set the view to highlight
                    } else {
                        document.getElementById('dashboard-view').classList.remove('hidden'); // Show dashboard view
                        highlightedView = 'dashboard'; // Set the view to highlight
                    }
                }
            } else if (view === 'account') { // NEW
                document.getElementById('account-view').classList.remove('hidden');
            }


            // 1. Reset all link highlights
            ['dashboard-link', 'scores-link', 'admin-link', 'account-link', 'dashboard-link-mobile', 'scores-link-mobile', 'admin-link-mobile', 'account-link-mobile'].forEach(id => { // NEW
                const link = document.getElementById(id);
                if (link) {
                    link.classList.remove('text-red-400', 'bg-gray-700');
                    link.classList.add('text-white');
                }
            });

            // 2. Highlight active links
            if (highlightedView) {
                const desktopLink = document.getElementById(`${highlightedView}-link`);
                const mobileLink = document.getElementById(`${highlightedView}-link-mobile`);
                if (desktopLink) {
                    desktopLink.classList.remove('text-white');
                    desktopLink.classList.add('text-red-400');
                }
                if (mobileLink) {
                    mobileLink.classList.remove('text-white');
                    mobileLink.classList.add('text-red-400', 'bg-gray-700');
                }
            }
        }
        
        /**
         * NEW: Updates all auth-related UI elements in the header
         */
        function updateAuthUI(user) {
            const welcome = document.getElementById('auth-welcome');
            const welcomeMobile = document.getElementById('auth-welcome-mobile');
            const actionBtn = document.getElementById('auth-action-btn');
            const actionBtnMobile = document.getElementById('auth-action-btn-mobile');
            const dashboardLink = document.getElementById('dashboard-link');
            const dashboardLinkMobile = document.getElementById('dashboard-link-mobile');
            const adminLink = document.getElementById('admin-link');
            const adminLinkMobile = document.getElementById('admin-link-mobile');
            const accountLink = document.getElementById('account-link'); // NEW
            const accountLinkMobile = document.getElementById('account-link-mobile'); // NEW
            const authStatusDiv = document.getElementById('auth-status');
            
            // authStatusDiv.classList.remove('hidden'); // <-- FIX: This line was breaking the mobile layout. Removing it allows Tailwind's 'hidden sm:flex' to work correctly.

            if (user && !user.isAnonymous) {
                // REAL USER
                // FIX: Check if user.email exists before splitting
                const emailShort = user.email ? user.email.split('@')[0] : 'User';
                const welcomeMsg = `Welcome, ${emailShort}`;
                welcome.textContent = welcomeMsg;
                welcomeMobile.textContent = welcomeMsg;
                actionBtn.textContent = 'Sign Out';
                actionBtnMobile.textContent = 'Sign Out';
                dashboardLink.style.display = 'block';
                dashboardLinkMobile.style.display = 'block';
                
                // NEW: Show Admin links only if user email matches ADMIN_EMAIL
                if (user.email === ADMIN_EMAIL) {
                    adminLink.style.display = 'block';
                    adminLinkMobile.style.display = 'block';
                } else {
                    adminLink.style.display = 'none';
                    adminLinkMobile.style.display = 'none';
                }

                accountLink.style.display = 'block'; // NEW
                accountLinkMobile.style.display = 'block'; // NEW
            } else {
                // ANONYMOUS GUEST
                const welcomeMsg = 'Welcome, Guest';
                welcome.textContent = welcomeMsg;
                welcomeMobile.textContent = welcomeMsg;
                actionBtn.textContent = 'Login / Register';
                actionBtnMobile.textContent = 'Login / Register';
                dashboardLink.style.display = 'none';
                dashboardLinkMobile.style.display = 'none';
                adminLink.style.display = 'none';
                adminLinkMobile.style.display = 'none';
                accountLink.style.display = 'none'; // NEW
                accountLinkMobile.style.display = 'none'; // NEW
            }
        }
        
        /**
         * NEW: Clears all active Firestore listeners on sign-out
         */
        function clearFirestoreListeners() {
            if (unsubscribeGameMetadata) unsubscribeGameMetadata();
            // REMOVED: No longer a separate listener
            // if (unsubscribeFollowedGames) unsubscribeFollowedGames();
            if (unsubscribeUserProfile) unsubscribeUserProfile();
            
            unsubscribeGameMetadata = null;
            // unsubscribeFollowedGames = null;
            unsubscribeUserProfile = null;
            
            console.log("Cleared all persistent Firestore listeners.");
        }
        
        /**
         * NEW: Sets up Firestore listeners based on auth state
         */
        function setupFirestoreListeners(currentUserId, isUserAnonymous) {
            // Clear any old listeners first
            clearFirestoreListeners();

            // --- 1. PUBLIC LISTENERS (Everyone gets these) ---
            const metadataColRef = getGameMetadataColRef(db);
            unsubscribeGameMetadata = onSnapshot(metadataColRef, (snapshot) => {
                const newMetadata = {};
                snapshot.forEach(doc => {
                    const data = doc.data();
                    newMetadata[doc.id] = { followerCount: Math.max(0, data.followerCount || 0) };
                });
                gameMetadata = newMetadata;
                console.log("Game metadata (follower counts) updated from public Firestore:", gameMetadata);

                if (!document.getElementById('scores-view').classList.contains('hidden')) {
                    renderScores();
                }
                if (!document.getElementById('dashboard-view').classList.contains('hidden')) {
                    renderFollowedGames();
                }
            }, (error) => {
                 console.error("Firestore onSnapshot (Public) error:", error);
                 showMessageBox("Data Sync Error", "Failed to sync public follower count data from the server.");
            });
            
            // --- 2. PRIVATE/AUTH-ONLY LISTENERS ---
            if (!isUserAnonymous && currentUserId) {
                // 2a. Private Followed Games - REMOVED
                /*
                const userDocRef = getFollowedGamesDocRef(db, currentUserId);
                if (userDocRef) {
                    unsubscribeFollowedGames = onSnapshot(userDocRef, (docSnap) => {
                        if (docSnap.exists() && docSnap.data().following) {
                            followedGames = docSnap.data().following;
                            console.log("Followed games updated from private Firestore:", followedGames);
                        } else {
                            followedGames = {}; 
                            console.log("No private followed games found, initialized to empty.");
                        }
                        renderFollowedGames();
                        if (!document.getElementById('scores-view').classList.contains('hidden')) {
                            renderScores();
                        }
                    }, (error) => {
                        console.error("Firestore onSnapshot (Private) error:", error);
                        showMessageBox("Data Sync Error", "Failed to sync followed games data from the server.");
                    });
                }
                */
                
                // 2b. Public Profile (Nickname AND Followed Games)
                const profileDocRef = getUserPublicProfileDocRef(db, currentUserId);
                unsubscribeUserProfile = onSnapshot(profileDocRef, (docSnap) => {
                    // NEW DEFAULT:
                    const emailPrefix = auth.currentUser?.email ? auth.currentUser.email.split('@')[0] : 'User';
                    const defaultNickname = emailPrefix; // Use email prefix as the base default
                    
                    let newNickname = null;
                    let newNicknameDisplay = defaultNickname;
                    
                    // MODIFIED: Get nickname AND followed games from the same doc
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        newNickname = data.nickname;
                        newNicknameDisplay = newNickname || defaultNickname; // Use saved nickname or default
                        followedGames = data.following || {}; // Get followed games from profile
                        console.log("Followed games updated from public profile:", followedGames);
                    } else {
                        followedGames = {}; // No profile doc, no followed games
                        console.log("No public profile found, followed games set to empty.");
                    }
                    
                    userNickname = newNickname; // Update global var
                    
                    // NEW: Update welcome message here
                    const welcome = document.getElementById('auth-welcome');
                    const welcomeMobile = document.getElementById('auth-welcome-mobile');
                    const welcomeMsg = `Welcome, ${newNicknameDisplay}`; 
                    welcome.textContent = welcomeMsg;
                    welcomeMobile.textContent = welcomeMsg;

                    // Update Account View
                    document.getElementById('current-nickname-display-account').textContent = newNicknameDisplay;
                    document.getElementById('nickname-input-account').value = newNickname || '';
                    
                    // MODIFIED: Call render functions that depend on followedGames
                    renderFollowedGames();
                    if (!document.getElementById('scores-view').classList.contains('hidden')) {
                        renderScores();
                    }

                }, (error) => {
                    console.error("Firestore onSnapshot (User Profile) error:", error);
                    document.getElementById('current-nickname-display').textContent = "Error loading nickname.";
                    document.getElementById('current-nickname-display-account').textContent = "Error loading nickname."; // NEW
                });
            } else {
                // Is anonymous, clear any potentially stale private data
                followedGames = {};
                userNickname = null;
            }
        }
        
        /**
         * NEW: Auth handler functions
         */
        async function handleRegister(e) {
            e.preventDefault();
            const email = document.getElementById('register-email').value;
            const password = document.getElementById('register-password').value;
            
            // NEW: Basic email regex validation
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

            if (!email || !password) {
                showMessageBox("Registration Error", "Please enter both an email and a password.");
                return;
            }

            // NEW: Specific email format check
            if (!emailRegex.test(email)) {
                showMessageBox("Registration Error", "The email address is not valid. Please check the format (e.g., user@example.com).");
                return;
            }
            
            // NEW: Specific password length check
            if (password.length < 6) {
                showMessageBox("Registration Error", "Your password must be at least 6 characters long.");
                return;
            }
            
            try {
                // await createUserWithEmailAndPassword(auth, email, password);
                const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                // NEW: After user is created, save their default nickname
                const newUserId = userCredential.user.uid;
                const emailPrefix = email.split('@')[0];
                const profileDocRef = getUserPublicProfileDocRef(db, newUserId);
                // MODIFIED: Add 'following: {}' on registration
                await setDoc(profileDocRef, { 
                    nickname: emailPrefix,
                    userId: newUserId,
                    following: {} 
                }, { merge: true });
                
                // onAuthStateChanged will handle the rest
            } catch (error) {
                console.error("Registration Error:", error);
                showMessageBox("Registration Failed", error.message);
            }
        }

        /**
         * NEW: Handles Google Sign-In (for both login and register)
         */
        async function handleGoogleSignIn() {
            const provider = new GoogleAuthProvider();
            try {
                const result = await signInWithPopup(auth, provider);
                const user = result.user;
                const additionalInfo = getAdditionalUserInfo(result);

                // Check if this is a brand new user
                if (additionalInfo.isNewUser) {
                    console.log("New user signed up with Google:", user.uid);
                    const newUserId = user.uid;
                    const email = user.email;
                    const emailPrefix = email ? email.split('@')[0] : 'User'; // Use email prefix or 'User'
                    const profileDocRef = getUserPublicProfileDocRef(db, newUserId);
                    
                    // Create their profile just like in handleRegister
                    await setDoc(profileDocRef, { 
                        nickname: emailPrefix,
                        userId: newUserId,
                        following: {} 
                    }, { merge: true });
                } else {
                    console.log("Returning user signed in with Google:", user.uid);
                }
                
                // onAuthStateChanged will handle view switching and loading data
                // No need to call switchView('dashboard') here

            } catch (error) {
                console.error("Google Sign-In Error:", error);
                // Handle common errors
                if (error.code === 'auth/popup-closed-by-user') {
                    showMessageBox("Sign-In Cancelled", "You closed the Google Sign-In window before completing the process.");
                } else if (error.code === 'auth/account-exists-with-different-credential') {
                    showMessageBox("Login Error", "An account already exists with this email address, but it was created with a different sign-in method (like email/password). Please log in using your original method.");
                } else {
                    showMessageBox("Google Sign-In Failed", error.message);
                }
            }
        }

        async function handleLogin(e) {
            e.preventDefault();
            const email = document.getElementById('login-email').value;
            const password = document.getElementById('login-password').value;

            if (!email || !password) {
                showMessageBox("Login Error", "Please enter both email and password.");
                return;
            }
            
            try {
                await signInWithEmailAndPassword(auth, email, password);
                // onAuthStateChanged will handle the rest
            } catch (error) {
                console.error("Login Error:", error);
                showMessageBox("Login Failed", error.message);
            }
        }

        async function handleSignOut() {
            try {
                await signOut(auth);
                // onAuthStateChanged will detect sign-out and then sign in anonymously
            } catch (error) {
                console.error("Sign Out Error:", error);
                showMessageBox("Sign Out Failed", error.message);
            }
        }

        /**
         * Initializes Firebase, signs in, and sets up the Firestore listener.
         */
        async function initFirebaseAndLoadData() {
            try {
                if (!resolvedFirebaseConfig.projectId || resolvedFirebaseConfig.projectId.includes("YOUR_PROJECT_ID")) {
                    showMessageBox("Configuration Error", "Firebase failed to initialize. Please update the 'USER_FIREBASE_CONFIG' object in the script with your actual project keys.");
                    return;
                }

                app = initializeApp(resolvedFirebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                // --- NEW: Set persistence to 'local' ---
                // This tells Firebase to save the user's session in localStorage,
                // so they stay logged in even after closing the browser tab.
                await setPersistence(auth, browserLocalPersistence);
                // --- End of new code ---
                
                // 1. Handle Authentication via state listener
                onAuthStateChanged(auth, async (user) => {
                    isAuthReady = true; // Auth state is now resolved
                    
                    if (user) {
                        // User is signed in (either real or anonymous)
                        userId = user.uid;
                        isAnonymous = user.isAnonymous;
                        
                        console.log(`User signed in: ${userId} (Anonymous: ${isAnonymous})`);

                        // Update all UI based on auth state
                        updateAuthUI(user);
                        
                        // Display User ID on Dashboard & Account views
                        // document.getElementById('user-id-display').textContent = userId; // REMOVED
                        document.getElementById('user-id-display-account').textContent = userId; // NEW

                        // Set up the correct listeners for this user
                        setupFirestoreListeners(userId, isAnonymous);

                        // Fetch scores for everyone
                        fetchEspnScores();
                        // Set up interval for refreshing scores
                        setInterval(fetchEspnScores, 30000); 
                        
                        // Go to Dashboard if real user, Scores if guest
                        switchView(isAnonymous ? 'scores' : 'dashboard');

                    } else {
                        // User is signed out
                        console.log("User is fully signed out. Signing in anonymously...");
                        isAnonymous = true;
                        userId = null;
                        clearFirestoreListeners(); // Clear all data listeners
                        updateAuthUI(null); // Update UI to "guest" state
                        
                        // Sign in as a guest
                        try {
                            await signInAnonymously(auth);
                            // This will re-trigger onAuthStateChanged with the new anonymous user
                        } catch (error) {
                             console.error("Anonymous sign-in error:", error);
                             showMessageBox("Guest Session Failed", `Could not start a guest session. Error: ${error.message}`);
                        }
                    }
                });
                
                // 2. Initial Sign-in check (only if no user is already cached)
                if (!auth.currentUser) {
                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                    } else {
                        await signInAnonymously(auth);
                    }
                }
                
                // 3. Set up static listeners
                document.getElementById('prompt-send-btn').addEventListener('click', handleNewPrompt);
                // document.getElementById('save-nickname-btn').addEventListener('click', handleSaveNickname); // REMOVED

                // START: NEW Admin listener for clearing leaderboard
                document.getElementById('clear-leaderboard-btn').addEventListener('click', handleClearLeaderboard);
                // END: NEW Admin listener

                // NEW: Account View Listeners
                document.getElementById('save-nickname-btn-account').addEventListener('click', handleSaveNickname);
                document.getElementById('change-password-btn').addEventListener('click', handleChangePassword);
                document.getElementById('delete-account-btn').addEventListener('click', () => {
                    showConfirmBox(
                        "Delete Account?", 
                        "This action is permanent and cannot be undone. Are you sure you want to delete your account?",
                        handleDeleteAccount // This function will be called if user clicks 'Confirm'
                    );
                });

            } catch (error) {
                console.error("Firebase Initialization Error:", error);
                showMessageBox("Initialization Failed", `Could not connect to the cloud service. Error: ${error.message}`);
            }
        }

        // --- Event Listeners and Initial Load ---
        
        // Mobile menu toggle listener
        document.getElementById('mobile-menu-button').addEventListener('click', () => {
            document.getElementById('mobile-menu').classList.toggle('hidden');
        });

        // Combined logic for all navigation links (Desktop and Mobile)
        const allNavLinks = [
            { id: 'admin-link', view: 'admin' },
            { id: 'dashboard-link', view: 'dashboard' },
            { id: 'scores-link', view: 'scores' },
            { id: 'account-link', view: 'account' }, // NEW
            { id: 'admin-link-mobile', view: 'admin' },
            { id: 'dashboard-link-mobile', view: 'dashboard' },
            { id: 'scores-link-mobile', view: 'scores' },
            { id: 'account-link-mobile', view: 'account' } // NEW
        ];

        allNavLinks.forEach(item => {
            const link = document.getElementById(item.id);
            if (link) {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (item.id.includes('-mobile')) {
                        document.getElementById('mobile-menu').classList.add('hidden');
                    }
                    switchView(item.view);
                });
            }
        });
        
        // Listener for Back button on Detail View
        document.getElementById('back-to-scores').addEventListener('click', (e) => {
            e.preventDefault();
            switchView('scores');
        });
        
        // NEW: Auth Action Button Listeners
        document.getElementById('auth-action-btn').addEventListener('click', () => {
            if (isAnonymous) {
                switchView('auth');
            } else {
                handleSignOut();
            }
        });
        document.getElementById('auth-action-btn-mobile').addEventListener('click', () => {
            document.getElementById('mobile-menu').classList.add('hidden');
            if (isAnonymous) {
                switchView('auth');
            } else {
                handleSignOut();
            }
        });

        // NEW: Auth Form Listeners
        document.getElementById('show-register-form').addEventListener('click', (e) => {
            e.preventDefault();
            document.getElementById('login-form').classList.add('hidden');
            document.getElementById('register-form').classList.remove('hidden');
        });
        document.getElementById('show-login-form').addEventListener('click', (e) => {
            e.preventDefault();
            document.getElementById('register-form').classList.add('hidden');
            document.getElementById('login-form').classList.remove('hidden');
        });
        
        document.getElementById('login-btn').addEventListener('click', handleLogin);
        document.getElementById('register-btn').addEventListener('click', handleRegister);
        
        // NEW: Google button listeners
        document.getElementById('google-login-btn').addEventListener('click', handleGoogleSignIn);
        document.getElementById('google-register-btn').addEventListener('click', handleGoogleSignIn);
        

        // Initialize the view and start fetching data when the window loads
        window.onload = initFirebaseAndLoadData;
    </script>
</body>
</html>
